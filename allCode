constants.js
{
const url = (x, y, z) => `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;

const numberOfDataPoints = 10;


const eventNames = ["Trash", "Wildlife", "Vandalism", "Weather", "Damage", "Other", "Dirt", "Fuel"];
const eventDatesWithHours = ["2024-10-18T12:00:00Z", "2024-10-15T12:00:00Z", "2024-10-12T12:00:00Z", "2024-10-17T12:00:00Z", "2024-10-11T12:00:00Z"];
const tableInfo = ["properties.name", "properties.date", "geometry.coordinates[1]", "geometry.coordinates[0]"];
var dateSpan = [new Date("2023-10-11T12:00:00Z"), new Date("2025-11-28T22:00:00Z")];
const latitudeRange = [50.08, 50.12];
const longitudeRange = [14.23, 14.28];
const nameWeights = [0.1, 0.1, 0.5, 0.1, 0.05, 0.35, 0.05, 0.05];
const latLonWeights = [1, 0.3];
var dataHandler = new DataClass(300, eventNames, latitudeRange, longitudeRange, nameWeights, latLonWeights);
var data = dataHandler.getData();
//console.log("Data from constants ");
// console.log(data);
var chartData = [];
//var linechart;
var chartName = dataHandler.getSelectedEventCounts().activeEventTypes;



const predefinedColors = d3.schemeCategory10;
const colorMapping = {};

const uniqueNames = [...new Set(data.map(d => d.properties.name))];
uniqueNames.forEach((name, index) => {
    colorMapping[name] = predefinedColors[index % predefinedColors.length];
});



var lineChartWidth = 0;
if (window.innerWidth == 1920) {
    //console.log("Setting line chart width to 1150");
    lineChartWidth = 1200;
}
else if (window.innerWidth > 1920) {
    //console.log("Setting line chart width to 1010");
    lineChartWidth = 1500;
}
else if (window.innerWidth < 1750) {
    //console.log("Setting line chart width to 850");
    lineChartWidth = 980;
}
else {
    lineChartWidth = 1000;
}



const lineChartNumberOfDashedLines = 5;
var gridLineDistanceGlobal = 0;


const deltas = [-3, -1, 0, 1];


//MAP Variables/Constants
var zoomableMap;

var pi = Math.PI,
    tau = 2 * pi;

const initX = -218505.76580430535;
const initY = 893059.666352264;
const initScale = 5534417.308186406;
var glyphs;
var data;
var svg;
var regions;
var rects;
var path = d3.geoPath().projection(projection);
var projection = d3.geoMercator()
    .scale(1 / tau)
    .translate([0, 0]);
var featureId = 6;

const startColor = "#ff0000";
const endColor = "#00ff00";

var colorScale = d3.scaleSequential(d3.interpolateHcl(startColor, endColor))
    .domain(dateSpan);
}
dataFiltering
{
    document.addEventListener('DOMContentLoaded', (event) => {
        // Initial setup
        document.getElementById('time-filter').addEventListener('change', handleTimeFilterChange);
        document.getElementById('start-date').addEventListener('change', handleDateChange);
        document.getElementById('end-date').addEventListener('change', handleDateChange);
        document.getElementById('search-event-types').addEventListener('focus', showHideGroup);
        document.getElementById('search-event-types').addEventListener('click', showHideGroup);
        document.getElementById('search-event-types').addEventListener('blur', hideGroupOnBlur);
        document.querySelector('.hide-group').addEventListener('mousedown', preventHideGroupUnfocus);
        document.querySelector('.hide-group').addEventListener('click', focusSearchEventTypes);
        document.getElementById('confirm-selection').addEventListener('click', confirmSelection);
        document.getElementById('dropdown').addEventListener('click', preventDropdownClose);
        document.getElementById('select-all').addEventListener('click', toggleSelectAll);
        document.querySelectorAll('.checkbox-group input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', handleCheckboxChange);
        });
        document.getElementById('confirm-selection').addEventListener('click', confirmSelection);
        window.addEventListener('click', closeDropdownOnOutsideClick);
        document.getElementById('search-event-types').addEventListener('input', filterEventTypes);
        // document.getElementById('apply-filters').addEventListener('click', applyFiltersOnClick);
        document.getElementById('reset-filters').addEventListener('click', resetFilters);
        document.getElementById("change-name-time").addEventListener("change", updateColorVisualization);
        document.getElementById('name').addEventListener('change', changeActiveSpanColor);
        document.getElementById('time').addEventListener('change', changeActiveSpanColor);
    
    
        document.getElementById('time').addEventListener('change', function () {
            document.getElementById('color-visualization').style.display = 'block';
            const selectedScale = d3[document.getElementById('colorScale').value];
            lineChart.updateColorScale(selectedScale);
        });
    
        document.getElementById('name').addEventListener('change', function () {
            document.getElementById('color-visualization').style.display = 'none';
            lineChart.updateColorScale("grayscale");
        });
    
        document.getElementById('colorScale').addEventListener('change', function () {
            const selectedScale = d3[this.value];
            lineChart.updateColorScale(selectedScale);
        });
    
    
    
        // Initial call to create checkboxes
        createCheckboxes(eventNames);
    
        // Automatically apply filters on page load
        const initialFilters = getFilters();
        applyFilters(initialFilters);
        showActiveFilters(initialFilters);
        changeActiveSpanColor();
        document.getElementById('time').dispatchEvent(new Event('change'));
        document.getElementById('colorScale').dispatchEvent(new Event('change'));
    });
    
    function handleTimeFilterChange() {
        console.log("Changing time filter");
        const customTime = document.getElementById('custom-time');
        customTime.style.display = this.value === 'custom' ? 'flex' : 'none';
        const filters = getFilters();
        applyFilters(filters);
        showActiveFilters(filters);
    }
    
    function handleDateChange() {
        const filters = getFilters();
        applyFilters(filters);
        showActiveFilters(filters);
    }
    
    function showHideGroup() {
        document.querySelector('.hide-group').style.display = 'block';
    }
    
    function hideGroupOnBlur(event) {
        if (!event.relatedTarget || !document.querySelector('.hide-group').contains(event.relatedTarget)) {
            document.querySelector('.hide-group').style.display = 'none';
        }
    }
    
    function preventHideGroupUnfocus(event) {
        event.preventDefault();
    }
    
    function focusSearchEventTypes() {
        document.getElementById('search-event-types').focus();
    }
    
    function confirmSelection() {
        document.querySelector('.hide-group').style.display = 'none';
        document.getElementById('dropdown').classList.remove('show');
        applyFilters(getFilters());
        showActiveFilters(getFilters());
    }
    
    function preventDropdownClose(event) {
        event.stopPropagation();
    }
    
    function handleCheckboxChange() {
        console.log('Checkbox state changed:', this.checked);
        updateSelectAllButtonText();
        updateSelectedEvents();
        const filters = getFilters();
        applyFilters(filters);
        showActiveFilters(filters);
    }
    
    function closeDropdownOnOutsideClick(event) {
        if (!event.target.matches('#select-event-types') && !event.target.closest('#dropdown')) {
            document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                if (dropdown.classList.contains('show')) {
                    dropdown.classList.remove('show');
                }
            });
        }
    }
    
    function filterEventTypes() {
        const filter = this.value.toLowerCase();
        document.querySelectorAll('.checkbox-group label').forEach(label => {
            label.style.display = label.textContent.toLowerCase().includes(filter) ? 'flex' : 'none';
        });
    }
    
    function applyFiltersOnClick() {
        const filters = getFilters();
        if (validateDateRange(filters.startDate, filters.endDate)) {
            applyFilters(filters);
            showActiveFilters(filters);
        } else {
            alert('Start date must be before end date.');
        }
    }
    
    function updateColorVisualization(event) {
        console.log('Color visualization changed:', event.target.value);
        zoomableMap.currentColorVisualization = event.target.value;
        zoomableMap.applyUpdates(getFilters().eventTypes);
    }
    
    function updateSelectedEvents() {
        const checkboxes = document.querySelectorAll('.checkbox-group input[type="checkbox"]');
        const selectedOptions = Array.from(checkboxes)
            .filter(i => i.checked)
            .map(i => `<span class="tag">${i.parentElement.textContent.trim()}</span>`)
            .join(' ');
    
        //console.log('Selected Event Types updated:', selectedOptions);
    }
    
    function updateSelectAllButtonText() {
        const checkboxes = document.querySelectorAll('.checkbox-group input[type="checkbox"]');
        const allSelected = Array.from(checkboxes).every(checkbox => checkbox.checked);
        document.getElementById('select-all').textContent = allSelected ? 'Unselect All' : 'Select All';
        updateSelectedEvents();
    }
    
    function getFilters() {
        const timeFilter = document.getElementById('time-filter').value;
        var startDate = document.getElementById('start-date').value;
        var endDate = document.getElementById('end-date').value;
        const eventTypes = Array.from(document.querySelectorAll('.checkbox-group input[type="checkbox"]:checked'))
            .map(checkbox => checkbox.value);
    
        if (timeFilter === 'past-7-days') {
            endDate = new Date();
            startDate = new Date();
            startDate.setDate(endDate.getDate() - 7);
            dateSpan = [startDate, endDate];
        } else if (timeFilter === 'past-30-days') {
            endDate = new Date();
            startDate = new Date();
            startDate.setDate(endDate.getDate() - 30);
            dateSpan = [startDate, endDate];
        } else if (timeFilter === 'custom') {
            startDate = startDate ? new Date(startDate) : null;
            endDate = endDate ? new Date(endDate) : null;
            dateSpan = [startDate, endDate];
        }
        return {
            timeFilter,
            startDate,
            endDate,
            eventTypes
        };
    }
    
    function resetFilters() {
        document.getElementById('time-filter').value = 'past-30-days';
        document.getElementById('custom-time').style.display = 'none';
        document.getElementById('start-date').value = '';
        document.getElementById('end-date').value = '';
        document.querySelectorAll('.checkbox-group input[type="checkbox"]').forEach(checkbox => {
            checkbox.checked = false;
        });
        document.getElementById('select-all').textContent = 'Select All';
        updateSelectedEvents();
        const filters = getFilters();
        applyFilters(filters);
        showActiveFilters(filters);
    
        data.forEach(point => {
            point.properties.selected = true;
        });
    
        console.log("Data after resetting filters:", data);
        document.getElementById('active-time-filter').innerHTML = 'Time Filter: <span class="active-time-filter">None</span>';
        document.getElementById('active-event-types').innerHTML = 'Event Types: <span class="active-event-types">None</span>';
    }
    
    function validateDateRange(startDate, endDate) {
        if (startDate && endDate) {
            return new Date(startDate) <= new Date(endDate);
        }
        return true;
    }
    
    function showActiveFilters(filters) {
        let timeFilterText;
        if (filters.timeFilter === 'past-7-days') {
            timeFilterText = 'Last 7d';
        } else if (filters.timeFilter === 'past-30-days') {
            timeFilterText = 'Last 30d';
        } else if (filters.timeFilter === 'custom') {
            // Assuming startDate and endDate are Date objects or strings in a standard format
            const start = new Date(filters.startDate).toLocaleDateString('en-US', { month: '2-digit', day: '2-digit' });
            const end = new Date(filters.endDate).toLocaleDateString('en-US', { month: '2-digit', day: '2-digit' });
            timeFilterText = `Custom (${start}-${end})`;
        } else {
            timeFilterText = 'None';
        }
        
    
        const eventTypesText = filters.eventTypes.length > 0 ? filters.eventTypes.join(', ') : 'None';
    
        document.getElementById('active-time-filter').innerHTML = `Time Filter: <span class="active-time-filter">${timeFilterText}</span>`;
        document.getElementById('active-event-types').innerHTML = "Event Types:";
        for (let i = 0; filters.eventTypes.length > 0 && i < filters.eventTypes.length; i++) {
            const eventTypeSpan = document.createElement('span');
            eventTypeSpan.className = 'active-tag';
            eventTypeSpan.textContent = filters.eventTypes[i];
            //add class name to eventTypeSpan based on event type
            eventTypeSpan.classList.add("activeColor" + filters.eventTypes[i]);
    
            //change color of eventTypeSpan background
    
            if (document.getElementById('name').checked) {
                eventTypeSpan.style.backgroundColor = colorMapping[filters.eventTypes[i]];
            }
    
    
    
            const removeSpan = document.createElement('span');
            removeSpan.className = 'remove';
            removeSpan.textContent = 'X';
            removeSpan.addEventListener('click', (event) => {
                event.stopPropagation();
                removeEventType(filters.eventTypes[i]);
            });
    
            eventTypeSpan.appendChild(removeSpan);
            document.getElementById('active-event-types').appendChild(eventTypeSpan);
        }
    
        if (filters.eventTypes.length === 0) {
            document.getElementById('active-event-types').innerHTML += `<span class="active-tag">None</span>`;
        }
    }
    
    function toggleSelectAll() {
        const checkboxes = document.querySelectorAll('.checkbox-group input[type="checkbox"]');
        const allSelected = Array.from(checkboxes).every(checkbox => checkbox.checked);
        checkboxes.forEach(checkbox => {
            checkbox.checked = !allSelected;
        });
        updateSelectAllButtonText();
        updateSelectedEvents();
        const filters = getFilters();
        applyFilters(filters);
        showActiveFilters(filters);
    }
    
    
    function onFilterUpdate() {
        // Find the <div class="dynamicChartName">
        var dynamicChartName = document.getElementsByClassName("dynamicChartName");
        var filters = getFilters();
    
        // Clear existing content
        while (dynamicChartName[0].firstChild) {
            dynamicChartName[0].removeChild(dynamicChartName[0].firstChild);
        }
    
        // Add each filter's eventTypes to dynamicChartName
        for (let i = 0; filters.eventTypes.length > 0 && i < filters.eventTypes.length; i++) {
            var element = document.createElement("span");
            element.className = "dynamicChartName";
            element.innerHTML = filters.eventTypes[i] + " ";
            dynamicChartName[0].appendChild(element);
        }
    }
    
    
    function applyFilters(filters) {
        // console.log('Applying filters:', filters);
        let startDate, endDate;
        //console.log('Applying filters:', filters);
    
        if (filters.timeFilter === 'past-7-days') {
            endDate = new Date();
            startDate = new Date();
            startDate.setDate(endDate.getDate() - 7);
            dateSpan = [startDate, endDate];
        } else if (filters.timeFilter === 'past-30-days') {
            endDate = new Date();
            startDate = new Date();
            startDate.setDate(endDate.getDate() - 30);
            dateSpan = [startDate, endDate];
        } else if (filters.timeFilter === 'custom') {
            startDate = filters.startDate ? new Date(filters.startDate) : null;
            endDate = filters.endDate ? new Date(filters.endDate) : null;
            dateSpan = [startDate, endDate];
        }
    
        data.forEach(point => {
            const eventName = point.properties.name;
            const eventDate = new Date(point.properties.date);
    
            const nameMatches = filters.eventTypes.includes(eventName);
            const dateMatches = (!startDate || eventDate >= startDate) && (!endDate || eventDate <= endDate);
    
            point.properties.selected = nameMatches && dateMatches;
            if (nameMatches && dateMatches) {
                point.properties.highlighted = false;
            }
        });
    
        // Update selectedEventTypes and eventOrder based on the filters
        selectedEventTypes = {};
        eventOrder = [];
    
        filters.eventTypes.forEach(eventType => {
            selectedEventTypes[eventType] = true; // Set the default to true if not already set
            if (!eventOrder.includes(eventType)) {
                eventOrder.push(eventType); // Add to the order array if not already present
            }
        });
    
        // Call the function to create or update the charts
        createMoreLineCharts();
    
    
        lineChart.updateChartData(dataHandler.getSelectedEventCounts().eventCounts);
        lineChart.deleteSelectionRectangle();
        lineChart.updateGridlines();
        zoomableMap.applyUpdates(filters.eventTypes);
        updateTableWithFilteredData();
        updateHighlightedSubcharts();
    }
    
    
    function createCheckboxes(eventNames) {
        const checkboxGroup = document.getElementsByClassName('checkbox-group')[0];
        if (checkboxGroup) {
            checkboxGroup.innerHTML = '';
    
            eventNames.forEach(event => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = event;
                checkbox.checked = true;
    
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(` ${event}`));
                checkboxGroup.appendChild(label);
    
                checkbox.addEventListener('change', function () {
                    console.log('Checkbox state changed:', this.checked);
                    updateSelectAllButtonText();
                    updateSelectedEvents();
                    const filters = getFilters();
                    applyFilters(filters);
                    showActiveFilters(filters);
                });
            });
            updateSelectedEvents();
            updateSelectAllButtonText();
        } else {
            console.error('No element with the class "checkbox-group" found.');
        }
    }
    
    function removeEventType(eventType) {
        document.querySelector(`.checkbox-group input[type="checkbox"][value="${eventType}"]`).checked = false;
        updateSelectAllButtonText();
        updateSelectedEvents();
        const filters = getFilters();
    
        applyFilters(filters);
        showActiveFilters(filters);
        changeActiveSpanColor();
    
    
    }
    
    
    
    
    
    
    function changeActiveSpanColor() {
        const nameRadioButton = document.getElementById('name');
    
        if (nameRadioButton.checked) {
            var filters = getFilters();
            //for each eventtype in filters.eventTypes
            for (let i = 0; filters.eventTypes.length > 0 && i < filters.eventTypes.length; i++) {
                //console.log(filters.eventTypes[i]);
                //find element with class activeColor + filters.eventTypes[i]
                var element = document.querySelector(".activeColor" + filters.eventTypes[i]);
                //console.log(element);
                //change color of element
                element.style.backgroundColor = colorMapping[filters.eventTypes[i]];
            }
        }
        else {
            //change color of active-time-filter
            var filters = getFilters();
            for (let i = 0; filters.eventTypes.length > 0 && i < filters.eventTypes.length; i++) {
                //console.log(filters.eventTypes[i]);
                //find element with class activeColor + filters.eventTypes[i]
                var element = document.querySelector(".activeColor" + filters.eventTypes[i]);
                //console.log(element);
                //revert color of element to #237e32
                element.style.backgroundColor = "#237e32";
    
            }
        }
    
    }
    
    
    
    
    
}
lineChart
{
    class LineChart {
        constructor(selector) {
            this.filters = getFilters();
            this.selector = selector;
            this.margin = { top: 20, right: 20, bottom: 20, left: 20 };
            this.width = lineChartWidth - this.margin.left - this.margin.right;
            this.height = 240 - this.margin.top - this.margin.bottom;
            this.currentXDomain = null;
            this.subLineCharts = [];
            this.isProgrammaticBrushMove = false;
            this.initChart();
            this.dataProportions = [];
            this.tickValues = [];
            this.loaded = false;
    
        }
    
        initChart() {
            this.linechartSvg = d3.select(this.selector)
                .append("svg")
                .attr("width", this.width + this.margin.left + this.margin.right)
                .attr("height", this.height + this.margin.top + this.margin.bottom)
                .append("g")
                .attr("transform", `translate(${this.margin.left},${this.margin.top})`);
    
            this.colorScale = d3.scaleSequential(d3.interpolateViridis);
    
            this.gradient = this.linechartSvg.append("defs")
                .append("linearGradient")
                .attr("id", "gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%");
    
            this.x = d3.scaleTime()
                .range([0, this.width]);
            this.xAxis = this.linechartSvg.append("g")
                .attr("transform", `translate(0,${this.height})`)
                .attr("class", "x-axis");
    
            this.y = d3.scaleLinear()
                .range([this.height, 0]);
            this.yAxis = this.linechartSvg.append("g")
                .attr("class", "y-axis");
    
            this.clip = this.linechartSvg.append("defs").append("clipPath")
                .attr("id", "clip")
                .append("rect")
                .attr("width", this.width)
                .attr("height", this.height + 20)
                .attr("x", 0)
                .attr("y", -20);
    
            this.brush = d3.brushX()
                .extent([[0, 0], [this.width, this.height]])
                .on("end", this.updateChart.bind(this));
    
            this.area = this.linechartSvg.append('g')
                .attr("clip-path", "url(#clip)");
    
            this.areaGenerator = d3.area()
                .x(d => this.x(d.date))
                .y0(this.y(0))
                .y1(d => this.y(d.value))
                .curve(d3.curveBasis);
    
            // Add gridlines
            this.xGrid = this.linechartSvg.append("g")
                .attr("class", "grid hidden-ticks")
                .attr("transform", `translate(0,${this.height})`);
        }
    
        updateColorScale(scale) {
            this.colorScale = d3.scaleSequential(scale);  // Update color scale
            //console.log("Recalculated domain " + dateSpan);
            this.colorScale.domain(dateSpan);  // Recalculate domain based on data
            this.updateGradientAndRedraw();  // Redraw the chart with the new color scale
        }
    
        updateGradientAndRedraw() {
            // Update the x domain with dateSpan for consistency
            this.x.domain(dateSpan);
    
            // Update the gradient
            this.gradient.selectAll("stop").remove();
            this.data.forEach((d, i) => {
                const color = d3.color(this.colorScale(d.date));
                this.gradient.append("stop")
                    .attr("offset", `${(i / (this.data.length - 1)) * 100}%`)
                    .attr("stop-color", color);
            });
    
            // Redraw the area chart with the updated gradient
            this.area.select('.myArea')
                .datum(this.data)
                .transition()
                .duration(1000)
                .attr("d", this.areaGenerator);
    
            // Redraw axes
            this.xAxis.transition().duration(1000).call(d3.axisBottom(this.x).ticks(3));
            this.yAxis.transition().duration(1000).call(d3.axisLeft(this.y).ticks(3));
        }
    
    
        renderChart(data) {
            this.data = data;
            // Set x domain to dateSpan rather than the data extent
            this.x.domain(dateSpan);
            this.xAxis.call(d3.axisBottom(this.x).ticks(3));  // Adjust the number of ticks as needed
            this.y.domain([0, d3.max(this.data, d => +d.value)]);  // Set y domain based on data values
    
            this.yAxis.call(d3.axisLeft(this.y).ticks(3));  // Fewer ticks on Y axis
    
            this.colorScale.domain(dateSpan);  // Adjust color scale domain if needed
    
            // Remove old gradient stops and recreate with updated color
            this.gradient.selectAll("stop").remove();
            this.data.forEach((d, i) => {
                let color = d3.color(this.colorScale(d.date));
                color = d3.rgb(color.r * 0.1, color.g * 0.1, color.b * 0.1); // Darken the color
                this.gradient.append("stop")
                    .attr("offset", `${(i / (this.data.length - 1)) * 100}%`)
                    .attr("stop-color", color);
            });
    
            // Update the area path
            this.area.selectAll(".myArea").remove();
            this.area.append("path")
                .datum(this.data)
                .attr("class", "myArea")
                .attr("fill", "url(#gradient)")
                .attr("fill-opacity", .7)
                .attr("stroke", "black")
                .attr("d", this.areaGenerator);
    
            // Attach the brush with updated selection
            this.area.selectAll(".brush").remove();
            this.area
                .append("g")
                .attr("class", "brush")
                .call(this.brush);
    
            // Update gridlines based on the new x domain
            //console.log("Domain before updateGridlines:", this.x.domain());
            this.updateGridlines();
        }
    
    
        addXAxisLabels() {
            // Remove any existing labels
            d3.select(`${this.selector} .x-axis-labels`).remove();
    
            // Create a container for the labels
            const labelsContainer = d3.select(this.selector)
                .append('div')
                .attr('class', 'x-axis-labels')
                .style('position', 'relative')
                .style('width', `${this.width}px`)
                .style('margin', '0 auto')
                .style('display', 'flex')
                .style('justify-content', 'space-between')
                .style('top', '20px'); // Adjust this value to position the labels correctly
    
            // Get the tick values from the X axis
            const tickValues = this.x.ticks(3);
    
            // Generate labels
            tickValues.forEach((d, i) => {
                labelsContainer.append('div')
                    .attr('class', 'x-axis-label')
                    .style('flex', '1')
                    .style('text-align', 'center')
                    .text(d3.timeFormat('%b %d %H:%m')(d)); // Format the date as needed
            });
        }
    
    
        updateGridlines() {
            const tickValues = this.x.ticks(lineChartNumberOfDashedLines);
            this.xGrid.call(d3.axisBottom(this.x).ticks(lineChartNumberOfDashedLines).tickSize(-this.height).tickFormat(""));
        }
    
    
        updateBrushFromSubChart(snappedExtent) {
            this.isProgrammaticBrushMove = true;
            d3.select(this.selector).select(".brush").call(this.brush.move, snappedExtent);
            this.isProgrammaticBrushMove = false;
        }
    
    
        //function to delete selection rectangle
        deleteSelectionRectangle() {
            this.clearBrush();
        }
    
        updateChart(event) {
            //console.log("Updating main chart with brush selection");
    
            const extent = event.selection;
            //this.updateGridlines();
            // If programmatically moving the brush, skip the rest of the update logic
            if (this.isProgrammaticBrushMove) {
                return;
            }
    
            // Select the tooltip element
            const tooltip = d3.select("#brush-tooltip");
            console.log("Tooltip:", tooltip);
    
            if (!extent) {
                // Hide tooltip if no selection
                tooltip.style("display", "none");
                return;
            }
    
            // Convert brush pixel positions to date values
            let [start, end] = [this.x.invert(extent[0]), this.x.invert(extent[1])];
            start.setHours(0, 0, 0, 0);
            end.setHours(0, 0, 0, 0);
            // add one day to end date to include the last day
            end.setDate(end.getDate() + 1);
            console.log("Brush selection range:", start, end);
            // Calculate the snapped pixel positions on the x scale using UTC dates
            const snappedExtent = [this.x(start), this.x(end)];
    
            d3.select(this.selector).select(".brush").call(this.brush.move, null);
    
            // Programmatically move the brush to snap to bins
            this.isProgrammaticBrushMove = true;
            d3.select(this.selector).select(".brush").call(this.brush.move, snappedExtent);
            this.isProgrammaticBrushMove = false;
    
    
    
            
    
    
            // Highlight data inside the snapped brush selection using UTC dates
            this.highlightDataInsideBrush(start, end);
    
            // Filter the data with the adjusted range in UTC
            const selectedData = this.data.filter(d => d.date >= start && d.date <= end);
    
            // Propagate brush selection to subcharts
            this.subLineCharts.forEach(subChart => {
                subChart.updateBrushFromMainChart(snappedExtent);
                subChart.updateChart(event, true);
            });
    
            this.highlightNewDataPoints(selectedData);
    
            // Update the brush selection rectangle style
            this.area.selectAll(".selection-rectangle").remove();
            this.area.append("rect")
                .attr("class", "selection-rectangle")
                .attr("x", snappedExtent[0])
                .attr("y", 0)
                .attr("width", snappedExtent[1] - snappedExtent[0])
                .attr("height", this.height)
                .on("mouseover", () => {
                    console.log("mouseover");
                    tooltip.style("display", "block");
                })
                .on("mousemove", (event) => {
                    console.log("mousemove");
                    const containerElement = d3.select(this.selector).node();
                    const containerBox = containerElement.getBoundingClientRect();
    
                    const midPoint = (snappedExtent[0] + snappedExtent[1]) / 2;
                    const tooltipX = midPoint + containerBox.left + this.margin.left;
                    const tooltipY = containerBox.top + this.margin.top;
    
                    // Format the timespan and set tooltip content
                    tooltip.html(`From: ${d3.timeFormat("%B %d, %Y %H:%M GMT")(start)}<br>To: ${d3.timeFormat("%B %d, %Y %H:%M GMT")(end)}`)
                        .style("left", `${tooltipX - 40}px`)
                        .style("top", `${tooltipY - 20}px`)
                        .style("transform", "translateX(-50%)");
                })
                .on("mouseout", () => {
                    tooltip.style("display", "none");
                });
        }
    
    
        updateChartData(newData) {
            // console.log(this.data);
            // console.log(newData);
            this.data = newData;
            // Set x domain to dateSpan instead of recalculating from data
            //this.x.domain(d3.extent(newData, d => d.date));
            this.x.domain(dateSpan);
            this.y.domain([0, d3.max(this.data, d => +d.value)]);
            this.colorScale.domain(dateSpan);
            //this.updateGridlines();
            // Update gradient
            this.gradient.selectAll("stop").remove();
            this.data.forEach((d, i) => {
                this.gradient.append("stop")
                    .attr("offset", `${(i / (this.data.length - 1)) * 100}%`)
                    .attr("stop-color", this.colorScale(d.date));
            });
    
            // Transition the area path
            this.area.select('.myArea')
                .datum(this.data)
                .transition()
                .duration(1000)
                .attr("d", this.areaGenerator);
    
            // Transition the X-axis with dateSpan domain
            this.xAxis.transition().duration(1000).call(d3.axisBottom(this.x).ticks(3));
    
            // Transition the Y-axis
            this.yAxis.transition().duration(1000).call(d3.axisLeft(this.y).ticks(3));
        }
    
    
        updateChartDataHighlight(newData) {
            const newDataPoints = newData; // Directly take the input as the data to highlight
            // Highlight the new data points in the chart
            this.highlightNewDataPoints(newDataPoints);
        }
    
        highlightNewDataPoints(newDataPoints) {
            //console.log("highlighting new data points");
            //console.log(newDataPoints);
            // Remove any previous highlights
            this.area.selectAll(".new-data-highlight").remove();
    
            // Remove any previous brush selection rectangle
            this.area.selectAll(".selection-rectangle").remove();
    
            // If there are new data points, create a programmatic brush selection
            if (newDataPoints.length > 0) {
                const minDate = d3.min(newDataPoints, d => d.date);
                const maxDate = d3.max(newDataPoints, d => d.date);
    
                // Set the brush extent based on the date range of newDataPoints
                const snappedExtent = [this.x(minDate), this.x(maxDate)];
    
                // Programmatically move the brush to cover the range of newDataPoints
                this.isProgrammaticBrushMove = true;
                d3.select(this.selector).select(".brush").call(this.brush.move, snappedExtent);
                this.isProgrammaticBrushMove = false;
                const tooltip = d3.select("#brush-tooltip");
                const snappedStart = this.x.invert(snappedExtent[0]);
            const snappedEnd = this.x.invert(snappedExtent[1]);
                // Update the brush selection rectangle to match the manual selection style
                this.area.append("rect")
                    .attr("class", "selection-rectangle")
                    .attr("x", snappedExtent[0])
                    .attr("y", 0)
                    .attr("width", snappedExtent[1] - snappedExtent[0])
                    .attr("height", this.height)
                    .on("mouseover", () => {
                        console.log("mouseover");
                        tooltip.style("display", "block");
                    })
                    .on("mousemove", (event) => {
                        const containerElement = d3.select(this.selector).node();
                        const containerBox = containerElement.getBoundingClientRect();
    
                        const midPoint = (snappedExtent[0] + snappedExtent[1]) / 2;
                        const tooltipX = midPoint + containerBox.left + this.margin.left;
                        const tooltipY = containerBox.top + this.margin.top;
    
                        // Use UTC date formatting
                        tooltip.html(`From: ${d3.timeFormat("%B %d, %Y %H:%M GMT")(snappedStart)}<br>To: ${d3.timeFormat("%B %d, %Y %H:%M GMT")(snappedEnd)}`)
                            .style("left", `${tooltipX - 40}px`)
                            .style("top", `${tooltipY - 20}px`)
                            .style("transform", "translateX(-50%)");
                    })
                    .on("mouseout", () => {
                        tooltip.style("display", "none");
                    });
            }
    
            // Group newDataPoints by day
            const dailyData = d3.group(newDataPoints, d => d3.timeDay(d.date));
    
            // Loop through each day's data to create individual areas
            dailyData.forEach((points) => {
                const sortedPoints = points.sort((a, b) => a.date - b.date);
    
                // Filter out points where the value (y) is 0
                const filteredPoints = sortedPoints.filter(d => d.value !== 0);
    
                // Only proceed if there are points remaining after filtering
                if (filteredPoints.length > 0) {
                    // Define an area generator for each day's points
                    const dayAreaGenerator = d3.area()
                        .x(d => this.x(d.date))
                        .y0(this.y(0))
                        .y1(d => this.y(d.value))
                        .curve(d3.curveBasis);
    
                    // Append a new area path for the current day's data points
                    this.area.append("path")
                        .datum(filteredPoints) // Use filtered points
                        .attr("class", "new-data-highlight")
                        .attr("clip-path", "url(#clip)")
                        .attr("d", dayAreaGenerator);
                }
            });
        }
    
    
        clearBrush() {
            //console.log("Clearing brush selection from the LineChart.");
            // Clear the brush selection by setting the extent to null
            this.isProgrammaticBrushMove = true;
            d3.select(this.selector).select(".brush").call(this.brush.move, null);
            this.isProgrammaticBrushMove = false;
    
            // Remove the selection rectangle and any highlights
            this.area.selectAll(".selection-rectangle").remove();
            this.area.selectAll(".new-data-highlight").remove();
    
            // Reset highlighted property for all data points
            this.data.forEach(point => {
                point.highlighted = false;
            });
            updateGlyphs();
        }
    
    
    
        highlightDataInsideBrush(start, end) {
            // Iterate through the data and highlight points within the adjusted range
            //console.log("Highlighting data inside brush range:", start, end);
            data.forEach(point => {
                const dateMatches = point.properties.date >= start && point.properties.date <= end;
                const element = document.getElementById(point.properties.id);
                //console.log(element);
    
                if (element) {  // Check if element is not null
                    if (dateMatches && point.properties.selected) {
                        point.properties.highlighted = true;
                        updateGlyphs();
                        element.classList.add("highlighted");
                    } else {
                        point.properties.highlighted = false;
                        //updateGlyphs();
                        //element.classList.remove("highlighted");
                    }
                } else {
                    console.warn(`Element with id ${point.properties.id} not found.`);
                }
            });
            highlightTableRows();
        }
    
    
    
    }
    
    // Add the event listener and call the functions
    document.addEventListener('DOMContentLoaded', (event) => {
        // Initial data load
        chartData = dataHandler.getSelectedEventCounts().eventCounts;
        lineChart = new LineChart("#my_dataviz");
        lineChart.renderChart(chartData);
        //console.log(zoomableMap);
        zoomableMap.setLinechart(lineChart);
    
    
        const scrollContainer = document.getElementById('hiddenCharts');
        const scrollAmount = 45; // Set this to the amount you want to scroll by each time
    
        scrollContainer.addEventListener('wheel', function (event) {
            // Prevent the default scroll behavior
            event.preventDefault();
    
            // Determine the scroll direction and set the new scroll position
            if (event.deltaY > 0) {
                // Scrolling down
                scrollContainer.scrollTop += scrollAmount;
            } else {
                // Scrolling up
                scrollContainer.scrollTop -= scrollAmount;
            }
        });
    });
}
seeMoreLinecharts.js
{
    // Object to store the state of selected checkboxes
let selectedEventTypes = {};

// Array to store the order of selected event types
let eventOrder = [];

let maxYValue = 0;

var eventSelection = document.getElementById('eventSelection');
eventSelection.classList.add('hidden');



document.getElementById('toggleButton').addEventListener('click', function () {
    
    var hiddenTexts = document.getElementById('hiddenCharts');
    var eventSelection = document.getElementById('eventSelection');
    var fixedLabelContainer = document.getElementById('fixed-labels-container');

    if (hiddenTexts.classList.contains('hidden')) {
        // Show hidden charts and event selection
        hiddenTexts.classList.remove('hidden');
        eventSelection.classList.remove('hidden');
        fixedLabelContainer.classList.remove('hidden');
        this.textContent = 'Close';

        // Populate the eventSelection div with checkboxes
        populateEventSelection();

        lineChart.xAxis.attr("class", "x-axis hidden-ticks");
        lineChart.xGrid.attr("class", "grid");
        updateOrderOfLineCharts(); // Update the line charts based on the selected checkboxes
        updateHighlightedSubcharts(); // Update the line charts based on the selected points
        //sortChartsByMaxYValue(); // Sort the charts by maximum Y value
        lineChart.updateGridlines();
        for (var i = 0; i < lineChart.subLineCharts.length; i++) {
            lineChart.subLineCharts[i].updateGridlines();
        }

    } else {
        // Hide hidden charts and event selection
        hiddenTexts.classList.add('hidden');
        eventSelection.classList.add('hidden');
        fixedLabelContainer.classList.add('hidden');
        this.textContent = 'See More';
        lineChart.subLineCharts = [];
        lineChart.xAxis.attr("class", "x-axis");
        lineChart.xGrid.attr("class", "grid hidden-ticks");
    }
});
let isHidden = true;
function populateEventSelection() {
    // Get active event types using dataHandler.getSelectedEventCounts()
    var somethingSelected = false;
    for (var i = 0; i < dataHandler.data.length; i++) {
        if (dataHandler.data[i].properties.selected && dataHandler.data[i].properties.highlighted) {
            somethingSelected = true;
            break;
        }
    }
    var activeEventTypes;
    if (somethingSelected) {
        activeEventTypes = dataHandler.getSelectedEventCounts().activeEventTypes;
    } else {
        activeEventTypes = dataHandler.getSelectedEventCounts().activeEventTypes;
    }
    //console.log('Active event types:', activeEventTypes);

    const eventSelection = document.getElementById('eventSelection');
    eventSelection.innerHTML = ''; // Clear previous selections

    // Create "hide/unhide all" button
    const hideAllContainer = document.createElement('div');
    hideAllContainer.classList.add('hide-all-container'); // Additional class for custom styling

    const hideAllButton = document.createElement('button');
    hideAllButton.id = 'hideAllButton';
    hideAllButton.textContent = 'Sort'; // Start with "Sort"

    hideAllButton.addEventListener('click', function () {
        isHidden = !isHidden;
        eventSelection.querySelectorAll('.checkbox-container:not(.hide-all-container)').forEach(container => {
            container.style.display = isHidden ? 'none' : 'flex';
        });
        hideAllButton.textContent = isHidden ? 'Sort' : 'Close';
        //get sortByMaxYButton and display it or hide it
        var sortByMaxYButton = document.getElementById('sortByMaxYButton');
        if (isHidden) {
            sortByMaxYButton.style.display = 'none';
        } else {
            sortByMaxYButton.style.display = 'block';
        }
    });
    hideAllContainer.appendChild(hideAllButton);
    eventSelection.appendChild(hideAllContainer);

    // Create a separate button for sorting by max Y value
    const sortButton = document.createElement('button');
    sortButton.id = 'sortByMaxYButton';
    sortButton.textContent = 'Max Y';

    // Add event listener to sort the charts by maximum Y value when clicked
    sortButton.addEventListener('click', function () {
        sortChartsByMaxYValue(); // Call the sorting function
    });

    //if checkbox-container is not hidden, display the sort button
    if (!isHidden) {
        sortButton.style.display = 'block';
    }

    hideAllContainer.appendChild(sortButton); // Append the sort button to the container

    const orderedEventTypes = eventOrder.length > 0 ? eventOrder : activeEventTypes;

// Iterate over each event type in the determined order and display checkboxes
orderedEventTypes.forEach((eventType, index) => {
        const checkboxContainer = document.createElement('div');
        checkboxContainer.classList.add('checkbox-container');
        checkboxContainer.dataset.eventType = eventType;

        // Set the background color based on the event type
        checkboxContainer.style.backgroundColor = colorMapping[eventType];

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `eventCheckbox_${index}`;
        checkbox.value = eventType;
        checkbox.checked = selectedEventTypes[eventType] !== undefined ? selectedEventTypes[eventType] : true;

        // Save the state when checkbox is clicked
        checkbox.addEventListener('change', function () {
            selectedEventTypes[eventType] = checkbox.checked;
            updateOrderOfLineCharts(); // Update charts when selection changes
            updateHighlightedSubcharts();
        });

        const label = document.createElement('label');
        label.htmlFor = `eventCheckbox_${index}`;
        label.textContent = " ";//eventType; // Display only the event type (no count)

        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(label);

        if (isHidden) {
            checkboxContainer.style.display = 'none'; // Initially hide all checkboxes
        } else {
            checkboxContainer.style.display = 'flex'; // Show all checkboxes
        }

        eventSelection.appendChild(checkboxContainer);
    });



    // Make the eventSelection div sortable
    new Sortable(eventSelection, {
        animation: 150,
        handle: '.checkbox-container', // Only allow dragging of elements with the class 'checkbox-container'
        filter: '.hide-all-container', // Exclude the container with the sort buttons from being dragged
        preventOnFilter: false, // Ensure that the filtered elements are not affected at all
        fallbackOnBody: true,  // Use body as a fallback for placing dragged elements
        fallbackTolerance: 10, // Tolerance before fallback kicks in to prevent dragging over non-draggable areas
        onMove: function (evt) {
            const target = evt.related;
            // Prevent dropping on the sort buttons
            if (target && target.classList.contains('hide-all-container')) {
                return false;
            }
        },
        onEnd: function (evt) {
            // Update the order of the checkboxes based on the manual drag order
            eventOrder = Array.from(eventSelection.children)
                .filter(container => !container.classList.contains('hide-all-container'))
                .map(container => container.dataset.eventType);
            
            // Persist the order and update charts accordingly
            updateOrderOfLineCharts();
            updateHighlightedSubcharts();
        }
    });
    
    
}







function updateOrderOfLineCharts() {
    console.log('Updating order of line charts');

    // Use the current event order to update the charts
    const allCheckboxes = Array.from(document.querySelectorAll('#eventSelection input[type="checkbox"]'));
    const orderedTypes = eventOrder.length > 0 
        ? eventOrder 
        : allCheckboxes.map(checkbox => checkbox.value);

    const container = document.getElementById('hiddenCharts');
    container.innerHTML = ''; // Clear the container before adding new charts

    orderedTypes.forEach((eventType, index) => {
        // Check if the corresponding checkbox is checked
        const isChecked = selectedEventTypes[eventType] !== undefined 
            ? selectedEventTypes[eventType] 
            : true;

        if (!isChecked) {
            return; // Skip rendering this chart if unchecked
        }

        const chartContainer = document.createElement('div');
        chartContainer.classList.add('chart-container');

        const label = document.createElement('span');
        label.classList.add('chart-label');
        label.textContent = eventType;

        // Set the color of the label based on the event type
        label.style.color = colorMapping[eventType];

        const newDiv = document.createElement('div');
        newDiv.id = `linechart_${index}`;
        newDiv.classList.add('linechart');

        // Set background color for the chart container if desired
        chartContainer.style.backgroundColor = colorMapping[eventType] + '15'; // Slightly transparent background

        chartContainer.appendChild(label); // Append the label next to the chart
        chartContainer.appendChild(newDiv);

        container.appendChild(chartContainer);

        const subChartData = dataHandler.getEventTypeData(eventType);
        const isLastChart = index === orderedTypes.length - 1;
        const subLineChart = new SubLineChart(`#linechart_${index}`, eventType, lineChart, isLastChart);
        subLineChart.renderChart(subChartData);

        lineChart.subLineCharts.push(subLineChart);
        subLineChart.x.domain([lineChart.x.domain()[0], lineChart.x.domain()[1]]);
        subLineChart.xAxis.call(d3.axisBottom(subLineChart.x).ticks(5));
        subLineChart.area
            .select('.myArea')
            .transition()
            .attr("d", subLineChart.areaGenerator)
            .style("fill", colorMapping[eventType]) // Apply color to the chart area
            .style("stroke", colorMapping[eventType]); // Apply color to the chart line

        changeMaxYBasedOnCurrentDatespan();
    });
}




function createMoreLineCharts() {
    populateEventSelection(); // Update the event selection div with the current state
    //console.log('Creating more line charts');
    const selectedCheckboxes = Array.from(document.querySelectorAll('#eventSelection input[type="checkbox"]:checked'));

    const selectedTypes = selectedCheckboxes.map(checkbox => checkbox.value);
    //console.log('Selected types:', selectedTypes);

    const container = document.getElementById('hiddenCharts');
    container.innerHTML = ''; // Clear the container before adding new charts



    selectedTypes.forEach((eventType, index) => {
        //console.log('Creating chart for:', eventType);
        //console.log("linechart subLineCharts", lineChart.subLineCharts);
        //lineChart.subLineCharts = [];
        const chartContainer = document.createElement('div');
        chartContainer.classList.add('chart-container');

        const label = document.createElement('span');
        label.classList.add('chart-label');
        label.textContent = eventType;

        // Set the color of the label based on the event type
        label.style.color = colorMapping[eventType];

        const newDiv = document.createElement('div');
        newDiv.id = `linechart_${index}`;
        newDiv.classList.add('linechart');

        // Set background color for the chart container if desired
        chartContainer.style.backgroundColor = colorMapping[eventType] + '15'; // Slightly transparent background

        chartContainer.appendChild(label); // Append the label next to the chart
        chartContainer.appendChild(newDiv);

        container.appendChild(chartContainer);

        const subChartData = dataHandler.getEventTypeData(eventType);
        const isLastChart = index === selectedTypes.length - 1;
        const subLineChart = new SubLineChart(`#linechart_${index}`, eventType, lineChart, isLastChart);


        subLineChart.renderChart(subChartData);

        lineChart.subLineCharts.push(subLineChart);
        //subLineChart.x.domain([lineChart.x.domain()[0], lineChart.x.domain()[1]]);
        subLineChart.xAxis.call(d3.axisBottom(subLineChart.x).ticks(5));
        subLineChart.area
            .select('.myArea')
            .transition()
            .attr("d", subLineChart.areaGenerator)
            .style("fill", colorMapping[eventType]) // Apply color to the chart area
            .style("stroke", colorMapping[eventType]); // Apply color to the chart line
        subLineChart.updateGridlines();
        subLineChart.clearBrush();
        //subLineChart.updateChartDataHighlight(subLineChart.data);
        // Transition the X-axis with dateSpan domain
        subLineChart.xAxis.transition().duration(1000).call(d3.axisBottom(subLineChart.x).ticks(3));

        // Transition the Y-axis
        subLineChart.yAxis.transition().duration(1000).call(d3.axisLeft(subLineChart.y).ticks(3));
        // Transition the area path
        subLineChart.area.select('.myArea')
            .datum(subLineChart.data)
            .transition()
            .duration(1000)
            .attr("d", subLineChart.areaGenerator);
        /*if (subLineChart.y.domain()[1] > maxYValue) {
            maxYValue = subLineChart.y.domain()[1];
        }
        subLineChart.changeYAxisRange(maxYValue);*/
        changeMaxYBasedOnCurrentDatespan();
    });
    // console.log("sublinecharts after creating", lineChart.subLineCharts);

}


function sortChartsByMaxYValue() {
    console.log('Sorting charts and checkboxes by maximum Y value within the current date span');

    const selectedCheckboxes = Array.from(document.querySelectorAll('#eventSelection input[type="checkbox"]'));

    var selectedTypes = selectedCheckboxes.map(checkbox => checkbox.value);

    var start = dateSpan[0];
    var end = dateSpan[1];

    // Get the maximum Y values for each event type within the current date span
    const maxYValues = selectedTypes.map(eventType => {
        let subChartData;

        // Check if any points are highlighted to determine which data to use
        if (dataHandler.isAnythingHighlighted()) {
            subChartData = dataHandler.getEventTypeData(eventType);
        } else {
            subChartData = dataHandler.getEventTypeData(eventType);
        }

        // Filter data to include only those within the current date span
        const filteredData = subChartData.filter(d => d.date >= start && d.date <= end);

        // Get the max Y value within the current date span
        const maxY = d3.max(filteredData, d => d.value); // Assuming 'value' is the property for Y-axis data
        return { eventType, maxY };
    });

    console.log('Max Y values before filtering:', maxYValues);

    // Filter out any eventTypes where maxY is undefined
    const filteredMaxYValues = maxYValues.filter(d => d.maxY !== undefined);

    console.log('Max Y values after filtering:', filteredMaxYValues);

    // Sort the event types by their maxY value in descending order
    const sortedEventTypes = filteredMaxYValues
        .sort((a, b) => b.maxY - a.maxY)
        .map(d => d.eventType);

    console.log('Sorted event types:', sortedEventTypes);

    // Update the eventOrder variable with the sorted order
    eventOrder = [...sortedEventTypes];

    // Sort the checkboxes based on the sorted event types
    const eventSelection = document.getElementById('eventSelection');
    const checkboxContainers = Array.from(eventSelection.querySelectorAll('.checkbox-container:not(.hide-all-container)'));

    // Clear the existing checkboxes and re-order them
    checkboxContainers.forEach(container => eventSelection.removeChild(container));

    // Append the checkboxes in the new sorted order
    sortedEventTypes.forEach(eventType => {
        const checkboxContainer = checkboxContainers.find(container => container.dataset.eventType === eventType);
        eventSelection.appendChild(checkboxContainer);
    });

    // Clear the container before adding new sorted charts
    const container = document.getElementById('hiddenCharts');
    container.innerHTML = '';

    // Re-render the sorted charts
    sortedEventTypes.forEach((eventType, index) => {
        // Check if the corresponding checkbox is selected
        const checkbox = selectedCheckboxes.find(cb => cb.value === eventType);
        if (!checkbox || !checkbox.checked) {
            // Skip rendering this chart if the checkbox is unchecked
            return;
        }

        const chartContainer = document.createElement('div');
        chartContainer.classList.add('chart-container');

        const label = document.createElement('span');
        label.classList.add('chart-label');
        label.textContent = eventType;

        // Set the color of the label based on the event type
        label.style.color = colorMapping[eventType];

        const newDiv = document.createElement('div');
        newDiv.id = `linechart_${index}`;
        newDiv.classList.add('linechart');

        // Set background color for the chart container if desired
        chartContainer.style.backgroundColor = colorMapping[eventType] + '15'; // Slightly transparent background

        chartContainer.appendChild(label); // Append the label next to the chart
        chartContainer.appendChild(newDiv);

        container.appendChild(chartContainer);

        const subChartData = dataHandler.getEventTypeData(eventType);
        const isLastChart = index === sortedEventTypes.length - 1;
        const subLineChart = new SubLineChart(`#linechart_${index}`, eventType, lineChart, isLastChart);
        subLineChart.renderChart(subChartData);

        lineChart.subLineCharts.push(subLineChart);
        subLineChart.x.domain([lineChart.x.domain()[0], lineChart.x.domain()[1]]);
        subLineChart.xAxis.call(d3.axisBottom(subLineChart.x).ticks(5));
        subLineChart.area
            .select('.myArea')
            .transition()
            .attr("d", subLineChart.areaGenerator)
            .style("fill", colorMapping[eventType]) // Apply color to the chart area
            .style("stroke", colorMapping[eventType]); // Apply color to the chart line

        // Set display based on checkbox state
        chartContainer.style.display = checkbox.checked ? 'flex' : 'none';

        // Update max Y-axis range for consistency based on the current date span
        changeMaxYBasedOnCurrentDatespan();
        updateHighlightedSubchartsAfterSort(); // Update the line charts based on the selected points
    });
}



function changeMaxYBasedOnCurrentDatespan() {
    var start = dateSpan[0];
    var end = dateSpan[1];
    var maxYValueDatespan = 0;

    // Calculate maxYValue for the current date span across all subLineCharts
    for (var i = 0; i < lineChart.subLineCharts.length; i++) {
        var subChart = lineChart.subLineCharts[i];
        var data = subChart.data;

        // Filter data points to only those within the dateSpan range
        var filteredData = data.filter(d => d.date >= start && d.date <= end);

        // Find the maximum Y value within the filtered data points
        var maxYForCurrentChart = d3.max(filteredData, d => d.value);

        // Update the overall maxYValueDatespan if the current chart has a higher value
        if (maxYForCurrentChart > maxYValueDatespan) {
            maxYValueDatespan = maxYForCurrentChart;
        }
    }
    //console.log("Calculated maxY " + maxYValueDatespan);
    // Change the max Y-axis range for each subLineChart to the calculated maxYValueDatespan
    for (var i = 0; i < lineChart.subLineCharts.length; i++) {
        lineChart.subLineCharts[i].changeYAxisRange(maxYValueDatespan);
    }
}
}
subLineChart.js
{
    class SubLineChart {
        constructor(selector, eventType, mainChart, isLastChart) {
            this.selector = selector;
            this.margin = { top: 20, right: 20, bottom: 0, left: 20 };
            this.width = lineChartWidth - this.margin.left - this.margin.right;
            //console.log("Width of " + eventType + " is " + this.width);
            this.height = 40 - this.margin.top - this.margin.bottom;
            this.eventType = eventType;
            this.mainChart = mainChart;
            this.isLastChart = isLastChart;
            if (isLastChart) {
                this.margin.bottom = 20;
                //console.log("Last chart");
                this.height = this.height + 0;
            }
            this.initChart();
            this.yTicks = 2;
            //this.updateGridlines();
            this.isProgrammaticBrushMove = false;
        }
    
        initChart() {
            this.linechartSvg = d3.select(this.selector)
                .append("svg")
                .attr("width", this.width + this.margin.left + this.margin.right)
                .attr("height", this.height + this.margin.top + this.margin.bottom)
                .style("overflow", "visible") // Ensure overflow is visible
                .append("g")
                .attr("transform", `translate(${this.margin.left},${this.margin.top})`);
    
            this.colorScale = d3.scaleSequential(d3.interpolateViridis);
    
            this.gradient = this.linechartSvg.append("defs")
                .append("linearGradient")
                .attr("id", "gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%");
    
            this.x = d3.scaleTime()
                .range([0, this.width]);
    
    
    
            this.xAxis = this.linechartSvg.append("g")
                .attr("transform", `translate(0,${this.height})`)
                .attr("class", this.isLastChart ? "x-axis hidden-ticks" : "x-axis hidden-ticks"); //remove hidden-ticks to show x-axis
    
            this.y = d3.scaleLinear()
                .range([this.height, 0]);
    
            this.yAxis = this.linechartSvg.append("g")
                .attr("class", "y-axis");
    
            this.clip = this.linechartSvg.append("defs").append("clipPath")
                .attr("id", "clip")
                .append("rect")
                .attr("width", this.width)
                .attr("height", this.height + 20) // Extend the height by 2 pixels
                .attr("x", 0)
                .attr("y", -20); // Shift the rectangle up by 2 pixels
    
            this.brush = d3.brushX()
                .extent([[0, 0], [this.width, this.height]])
                .on("end", this.updateChart.bind(this));
    
            this.area = this.linechartSvg.append('g')
                .attr("clip-path", "url(#clip)");
    
            this.areaGenerator = d3.area()
                .x(d => this.x(d.date))
                .y0(this.y(0))
                .y1(d => this.y(d.value))
                .defined(d => d.value !== 0) // Only include non-zero points for the area fill
                .curve(d3.curveBasis);
            this.zeroLineGenerator = d3.line()
                .x(d => this.x(d.date))
                .y(() => this.y(0)) // Fixed y-coordinate at y = 0
                .curve(d3.curveBasis);
    
            // Add gridlines
            this.xGrid = this.linechartSvg.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0,${this.height})`);
    
            // Add gridline labels
            this.labels = this.linechartSvg.append("g")
                .attr("class", "grid-labels");
    
        }
    
        renderChart(data) {
            this.data = data;
    
            // Set x domain to dateSpan rather than the data extent
            this.x.domain(dateSpan);
            this.xAxis.call(d3.axisBottom(this.x).ticks(3));  // Adjust the number of ticks as needed
            this.y.domain([0, d3.max(this.data, d => +d.value)]);  // Set y domain based on data values
    
            this.yAxis.call(d3.axisLeft(this.y).ticks(3));  // Fewer ticks on Y axis
    
            this.colorScale.domain(d3.extent(this.data, d => d.date));  // Adjust color scale domain if needed
    
            // Remove old gradient stops and recreate with updated color
            this.gradient.selectAll("stop").remove();
            this.data.forEach((d, i) => {
                let color = d3.color(this.colorScale(d.date));
                color = d3.rgb(color.r * 0.1, color.g * 0.1, color.b * 0.1); // Darken the color
                this.gradient.append("stop")
                    .attr("offset", `${(i / (this.data.length - 1)) * 100}%`)
                    .attr("stop-color", color);
            });
    
            // Update the area path
            this.area.selectAll(".myArea").remove();
            this.area.append("path")
                .datum(this.data)
                .attr("class", "myArea")
                .attr("fill", colorMapping[this.eventType]) // Use the color from colorMapping
                .attr("fill-opacity", 1)
                .attr("stroke", d3.color(colorMapping[this.eventType]).darker(1)) // Use the color from colorMapping
                .attr("stroke-width", 1)
                .attr("d", this.areaGenerator);
            this.area.append("line")
                .attr("class", "zero-line")
                .attr("x1", this.x(new Date(dateSpan[0]))) // Start of dateSpan
                .attr("y1", this.y(0) + 1) // y = 0
                .attr("x2", this.x(new Date(dateSpan[1]))) // End of dateSpan
                .attr("y2", this.y(0) + 1) // y = 0
                .attr("stroke", "black")
                .attr("stroke-width", 2);
    
            // Attach the brush with updated selection
            this.area.selectAll(".brush").remove();
            this.area
                .append("g")
                .attr("class", "brush")
                .call(this.brush);
    
            // Update gridlines based on the new x domain
            this.updateGridlines();
        }
    
        updateGridlines() {
            this.isLastChart = false;
            // Clear any existing lines and labels to prevent overlap
            this.xGrid.selectAll("line").remove();
            this.labels.selectAll("text").remove();
    
            const tickValues = this.x.ticks(lineChartNumberOfDashedLines);
            //console.log("Sublinechart tickValues: " + tickValues);
            const start = this.x.domain()[0];
            const end = this.x.domain()[1];
    
            // Calculate distance between grid lines
            const tickPositions = tickValues.map(tick => this.x(tick)); // Convert tick values to pixel positions
            let gridLineDistance = 0;
            if (tickPositions.length > 1) {
                gridLineDistance = Math.abs(tickPositions[1] - tickPositions[0]); // Calculate the distance between the first two ticks
            }
    
            // Set global grid line distance
            gridLineDistanceGlobal = gridLineDistance;
    
            // Append vertical grid lines for each tick and create labels
            var fixedLabelsContainer = d3.select('#fixed-labels-container');
            fixedLabelsContainer.selectAll("div").remove(); // Remove previous divs to avoid overlaps
    
    
            tickValues.concat(start, end).forEach((tickValue, i) => {
                const isStartOrEnd = (tickValue === start || tickValue === end);
                const xPosition = this.x(tickValue);
    
                // Create the line and apply common attributes
                const line = this.xGrid.append("line")
                    .attr("x1", xPosition)
                    .attr("x2", xPosition)
                    .attr("y1", 0)
                    .attr("y2", -this.height - 42)
                    .attr("stroke", "currentColor")
                    .attr("stroke-width", 3); // Adjust stroke width as needed
    
                // If the tick value is not the start or end, apply dashed stroke
                if (!isStartOrEnd) {
                    line.attr("stroke-dasharray", "2.5");
    
                    if (this.isLastChart) {
                        const labelClass = i === 0 ? "grid-label bottom-labels first-bottom-label" : "grid-label bottom-labels";
                        const labelDivClass = i === 0 ? "label-div first-bottom-label" : "label-div";
    
                        // Insert dummy div if it's the first label
                        if (i == 0) {
                            const dummyDiv = fixedLabelsContainer.append("div")
                                .attr("class", "dummy-div")
                                .style("width", gridLineDistance + computeFirstOffset() - 10 + "px")
                                .style("display", "inline-block");
    
                            console.log(`Dummy div inserted with width: ${gridLineDistance + computeFirstOffset() - 10}px for chart: ${this.eventType}`);
                        }
    
                        var width = gridLineDistance;
                        if (i === tickValues.length - 1) {
                            width = 0;
                        }
                        console.log("width: " + width);
                        // Create a new div for each label with fixed width of gridLineDistance
                        const labelDiv = fixedLabelsContainer.append("div")
                            .attr("class", labelDivClass)
                            .style("width", width + "px") // Set width to gridLineDistance
                            .style("display", "inline-block");
    
                        // Append the text labels inside the created div
                        labelDiv.append("text")
                            .attr("dy", "2em")
                            .attr("class", labelClass) // Add the dynamic class
                            .style("font-size", "10px") // Adjust font size as needed
                            .style("fill", "black") // Change color
                            .style("font-weight", "bold") // Bold text
                            .style("opacity", 0.8) // Adjust opacity if needed
                            .text(this.formatDate(tickValue))
                            .style("overflow", "visible"); // Ensure overflow is visible
    
                        //console.log(`Label created for tick value: ${tickValue}, text: ${this.formatDate(tickValue)}, chart: ${this.eventType}`);
                    }
                }
            });
        }
    
    
        updateBrushFromMainChart(snappedExtent) {
            // Clear existing brush selection
            d3.select(this.selector).select(".brush").call(this.brush.move, null);
    
            // Programmatically move the brush
            this.isProgrammaticBrushMove = true;
            d3.select(this.selector).select(".brush").call(this.brush.move, snappedExtent);
            this.isProgrammaticBrushMove = false;
    
        }
    
    
    
        updateChart(event, calledFromMainChart = false) {
    
            const extent = event.selection;
    
            // If programmatically moving the brush, skip the rest of the update logic
            if (this.isProgrammaticBrushMove) {
                return;
            }
    
            // Select the tooltip element
            const tooltip = d3.select("#brush-tooltip");
    
            if (!extent) {
                // Hide tooltip if no selection
                tooltip.style("display", "none");
                return;
            }
    
            // Convert brush pixel positions to date values
            let [start, end] = [this.x.invert(extent[0]), this.x.invert(extent[1])];
            start.setHours(0, 0, 0, 0);
            end.setHours(0, 0, 0, 0);
            // add one day to end date to include the last day
            end.setDate(end.getDate() + 1);
            //console.log("Brush selection range:", start, end);
            // Calculate the snapped pixel positions on the x scale using UTC dates
            const snappedExtent = [this.x(start), this.x(end)];
    
            d3.select(this.selector).select(".brush").call(this.brush.move, null);
    
            // Programmatically move the brush to snap to bins
            this.isProgrammaticBrushMove = true;
            d3.select(this.selector).select(".brush").call(this.brush.move, snappedExtent);
            this.isProgrammaticBrushMove = false;
    
            //this.mainChart.updateBrushFromSubChart(snappedExtent);
    
    
    
            // Highlight data inside the snapped brush selection using UTC dates
            if (!calledFromMainChart) {
                this.highlightDataInsideBrush(start, end);
                //updateHighlightedSubcharts();
            }
    
    
            //const adjustedEndUTC = new Date(end.getTime() + bufferDuration);
            // Filter the data with the adjusted range in UTC
            const selectedData = this.data.filter(d => d.date >= start && d.date <= end);
            //console.log("Selected data (UTC range):", selectedData);
    
            // Call `highlightNewDataPoints` with the selected data
            this.highlightNewDataPoints(selectedData);
    
            // Update the brush selection rectangle style
            this.area.selectAll(".selection-rectangle-subchart").remove();
            this.area.append("rect")
                .attr("class", "selection-rectangle-subchart")
                .attr("x", snappedExtent[0])
                .attr("y", 0)
                .attr("width", snappedExtent[1] - snappedExtent[0])
                .attr("height", this.height)
                .on("mouseover", () => {
                    console.log("mouseover");
                    tooltip.style("display", "block");
                })
                .on("mousemove", (event) => {
                    const containerElement = d3.select(this.selector).node();
                    const containerBox = containerElement.getBoundingClientRect();
    
                    const midPoint = (snappedExtent[0] + snappedExtent[1]) / 2;
                    const tooltipX = midPoint + containerBox.left + this.margin.left;
                    const tooltipY = containerBox.top + this.margin.top;
    
                    // Use UTC date formatting
                    tooltip.html(`From: ${d3.timeFormat("%B %d, %Y %H:%M GMT")(start)}<br>To: ${d3.timeFormat("%B %d, %Y %H:%M GMT")(end)}`)
                        .style("left", `${tooltipX - 60}px`)
                        .style("top", `${tooltipY - 40}px`)
                        .style("transform", "translateX(-50%)");
                })
                .on("mouseout", () => {
                    tooltip.style("display", "none");
                });
    
        }
    
        updateChartDataHighlight(newData) {
            const newDataPoints = newData; // Directly take the input as the data to highlight
            console.log("newDataPoints: " + newDataPoints);
            // Highlight the new data points in the chart
            this.highlightNewDataPoints(newDataPoints);
        }
    
        highlightNewDataPoints(newDataPoints) {
            //console.log("highlighting new data points");
            //console.log(newDataPoints);
            // Remove any previous highlights
            this.area.selectAll(".new-data-highlight-subchart").remove();
    
            // Remove any previous brush selection rectangle
            this.area.selectAll(".selection-rectangle-subchart").remove();
    
            // If there are new data points, create a programmatic brush selection
            if (newDataPoints.length > 0) {
                const minDate = d3.min(newDataPoints, d => d.date);
                const maxDate = d3.max(newDataPoints, d => d.date);
    
                // Set the brush extent based on the date range of newDataPoints
                const snappedExtent = [this.x(minDate), this.x(maxDate)];
    
                // Programmatically move the brush to cover the range of newDataPoints
                this.isProgrammaticBrushMove = true;
                d3.select(this.selector).select(".brush").call(this.brush.move, snappedExtent);
                this.isProgrammaticBrushMove = false;
                // Select the tooltip element
                const tooltip = d3.select("#brush-tooltip");
                const snappedStart = this.x.invert(snappedExtent[0]);
            const snappedEnd = this.x.invert(snappedExtent[1]);
                // Update the brush selection rectangle to match the manual selection style
                this.area.append("rect")
                    .attr("class", "selection-rectangle-subchart")
                    .attr("x", snappedExtent[0])
                    .attr("y", 0)
                    .attr("width", snappedExtent[1] - snappedExtent[0])
                    .attr("height", this.height)
                    .on("mouseover", () => {
                        console.log("mouseover");
                        tooltip.style("display", "block");
                    })
                    .on("mousemove", (event) => {
                        const containerElement = d3.select(this.selector).node();
                        const containerBox = containerElement.getBoundingClientRect();
    
                        const midPoint = (snappedExtent[0] + snappedExtent[1]) / 2;
                        const tooltipX = midPoint + containerBox.left + this.margin.left;
                        const tooltipY = containerBox.top + this.margin.top;
    
                        // Use UTC date formatting
                        tooltip.html(`From: ${d3.timeFormat("%B %d, %Y %H:%M GMT")(snappedStart)}<br>To: ${d3.timeFormat("%B %d, %Y %H:%M GMT")(snappedEnd)}`)
                            .style("left", `${tooltipX - 60}px`)
                            .style("top", `${tooltipY - 40}px`)
                            .style("transform", "translateX(-50%)");
                    })
                    .on("mouseout", () => {
                        tooltip.style("display", "none");
                    });
            }
    
            // Group newDataPoints by day
            const dailyData = d3.group(newDataPoints, d => d3.timeDay(d.date));
    
            // Loop through each day's data to create individual areas
            dailyData.forEach((points) => {
                const sortedPoints = points.sort((a, b) => a.date - b.date);
    
                // Filter out points where the value (y) is 0
                const filteredPoints = sortedPoints.filter(d => d.value !== 0);
    
                // Only proceed if there are points remaining after filtering
                if (filteredPoints.length > 0) {
                    // Define an area generator for each day's points
                    const dayAreaGenerator = d3.area()
                        .x(d => this.x(d.date))
                        .y0(this.y(0))
                        .y1(d => this.y(d.value))
                        .curve(d3.curveBasis);
    
                    // Append a new area path for the current day's data points
                    this.area.append("path")
                        .datum(filteredPoints) // Use filtered points
                        .attr("class", "new-data-highlight-subchart")
                        .attr("clip-path", "url(#clip)")
                        .attr("d", dayAreaGenerator);
                }
            });
    
        }
    
    
    
        clearBrush() {
            //console.log("Clearing brush selection from the LineChart.");
            // Clear the brush selection by setting the extent to null
            this.isProgrammaticBrushMove = true;
            d3.select(this.selector).select(".brush").call(this.brush.move, null);
            this.isProgrammaticBrushMove = false;
    
            // Remove the selection rectangle and any highlights
            this.area.selectAll(".selection-rectangle-subchart").remove();
            this.area.selectAll(".new-data-highlight-subchart").remove();
    
            // Reset highlighted property for all data points
            this.data.forEach(point => {
                point.highlighted = false;
            });
            updateGlyphs();
        }
    
    
        highlightDataInsideBrush(start, end) {
            // Iterate through the data and highlight points within the adjusted range
            //console.log("Highlighting data inside brush range:", start, end);
            data.forEach(point => {
                const dateMatches = point.properties.date >= start && point.properties.date <= end;
                const element = document.getElementById(point.properties.id);
    
                if (element) {  // Check if element is not null
                    if (dateMatches && point.properties.selected) {
                        point.properties.highlighted = true;
                        updateGlyphs();
                        element.classList.add("highlighted");
                    } else {
                        point.properties.highlighted = false;
                        updateGlyphs();
                        element.classList.remove("highlighted");
                    }
                } else {
                    //console.warn(`Element with id ${point.properties.id} not found.`);
                }
            });
        }
    
        updateChartDataHighlight(newData) {
            //console.log("updating sublinechart highlight");
            //console.log("linechart type is " + this.eventType);
            // Keep track of previous data for comparison
            /*const previousData = this.data || [];
    
            // Identify new data points by checking if the new data contains points not in the previous data
            const newDataPoints = newData.filter(newPoint => {
                return !previousData.some(prevPoint =>
                    prevPoint.date.getTime() === newPoint.date.getTime() &&
                    prevPoint.value === newPoint.value
                );
            });*/
            const newDataPoints = newData;
            // Highlight the new data points in the chart
            this.highlightNewDataPoints(newDataPoints);
        }
    
    
        updateChartFromOutside(newXDomain) {
            console.log("updating from outside");
            if (newXDomain) {
                this.x.domain(newXDomain);
            }
            this.xAxis.transition().duration(1000).call(d3.axisBottom(this.x).ticks(3));
            this.yAxis.transition().duration(1000).call(d3.axisLeft(this.y).ticks(2));
            this.area
                .select('.myArea')
                .transition()
                .duration(1000)
                .attr("d", this.areaGenerator);
    
            // Update gridlines and labels
            //this.updateGridlineLabels();
        }
    
    
        interpolateDates(start, end, numberOfPoints) {
            const startTime = new Date(start).getTime(); // Convert start date to milliseconds
            const endTime = new Date(end).getTime(); // Convert end date to milliseconds
            const interval = (endTime - startTime) / (numberOfPoints - 1); // Calculate the time interval
    
            const interpolatedDates = []; // Array to store interpolated dates
            for (let i = 0; i < numberOfPoints; i++) {
                const currentTime = startTime + i * interval; // Calculate current time
                interpolatedDates.push(new Date(currentTime)); // Convert back to Date object and add to array
            }
    
            return interpolatedDates;
        }
    
        updateGridlineLabels() {
            const tickValues = this.x.ticks(lineChartNumberOfDashedLines);
            const start = this.x.domain()[0];
            const end = this.x.domain()[1];
    
            const interpolatedDates = this.interpolateDates(start, end, lineChartNumberOfDashedLines + 1);
    
            // Reference the dummy div and its original width
            const dummyDiv = d3.select('.dummy-div');
            const originalWidth = parseFloat(dummyDiv.style('width'));
    
            // Measure initial label width
            const beforeTextWidth = d3.select('.grid-label').node()?.getBoundingClientRect().width || 0;
    
            // Update the text labels based on interpolated dates
            tickValues.concat(start, end).forEach((tickValue, i) => {
                const xPosition = this.x(tickValue);
                const label = d3.selectAll(".grid-label").nodes();
    
                if (label[i]) {
                    label[i].innerHTML = this.formatDate(interpolatedDates[i + 1]);
                    d3.select(label[i]).text(this.formatDate(interpolatedDates[i + 1]));
                }
            });
    
            // Measure updated label width
            const afterTextWidth = d3.select('.grid-label').node()?.getBoundingClientRect().width || 0;
            const widthDifference = beforeTextWidth - afterTextWidth;
    
            // Apply width adjustment only if the difference exceeds a threshold (e.g., 1px)
            const minAdjustmentThreshold = 1;
            if (Math.abs(widthDifference) > minAdjustmentThreshold) {
                const newWidth = Math.max(originalWidth + widthDifference / 2, originalWidth);
                dummyDiv.style('width', newWidth + 'px');
            }
        }
    
    
    
    
        formatDate(date) {
            const diff = this.x.domain()[1] - this.x.domain()[0];
            if (diff < 7 * 24 * 60 * 60 * 1000) { // If the range is less than a week
                return d3.timeFormat("%d/%m %H:%M")(date); // Show day, month, hour, and minute
            } else if (diff < 30 * 24 * 60 * 60 * 1000) { // If less than a month
                return d3.timeFormat("%d/%m")(date); // Show day and month
            } else {
                return d3.timeFormat("%m/%Y")(date); // Show month and year
            }
        }
    
        changeYAxisRange(maxYValue) {
            //console.log("redrawing y with - " + maxYValue);
            // Update the y scale with new min and max values
            this.y.domain([0, maxYValue]);
    
            // Update the y-axis with new domain
            this.yAxis.transition()  // Add a transition for smoother updates, optional
                .duration(0)       // Adjust duration as needed
                .call(d3.axisLeft(this.y).ticks(this.yTicks));  // Ensure ticks are based on updated domain
    
            // Redraw the chart area with the updated y scale
            this.area.select('.myArea')
                .transition()
                .duration(0)  // Optional, you can control the transition duration
                .attr("d", this.areaGenerator);  // Update the path with the new Y-domain
    
        }
    
        //return max value of y axis
        getMaxYValue() {
            return d3.max(this.data, d => +d.value);
        }
    
    
    }
    
}
map.js
{
    function updateGlyphs() {
        glyphs.selectAll("path")
            .attr("d", d3.geoPath().projection(projection)) // Update the path data based on the projection
            .each(function (d) {
                if (!d.properties.selected) {
                    d.properties.highlighted = false; // Ensure highlighted is false if not selected
                }
    
                const currentPath = d3.select(this); // Select the current path element
    
                // Calculate the centroid of the path for scaling
                const pathCentroid = d3.geoPath().projection(projection).centroid(d);
    
                currentPath
                    .attr("fill", currentPath.attr("fill")) // Preserve the original fill color
                    //.attr("stroke-linejoin", "round") // Smooth edges for the halo effect
                    .attr("display", d => d.properties.selected ? "auto" : "none") // Control visibility based on selection
                    .attr("transform", d => {
                        if (d.properties.highlighted) {
                            // Apply scaling relative to the centroid
                            return `translate(${pathCentroid[0]}, ${pathCentroid[1]}) scale(1.4) translate(${-pathCentroid[0]}, ${-pathCentroid[1]})`;
                        } else {
                            return null; // Reset transform if not highlighted
                        }
                    })
                    .classed("mapPoint", true) // Always add "mapPoint"
                    .classed("highlighted point", d => d.properties.highlighted); // Add "highlighted" and "point" only if highlighted
    
                if (d.properties.highlighted) {
                    currentPath.raise(); // Move the element to the end
                }
            });
    }
    
    
    
    
    
    
    class ZoomableMap {
        constructor() {
            this.initialTransform = d3.zoomIdentity.translate(initX, initY).scale(initScale);
            //console.log("Client width: " + document.getElementById("map").clientWidth);
            //console.log("Client height: " + document.getElementById("map").clientHeight);
            //get width and height of the svg element
            this.svgWidth = document.getElementById("map").clientWidth;
    
            this.width = document.getElementById("map").clientWidth;
            this.height = document.getElementById("map").clientHeight;
            this.showlayers = false;
            this.mapElement = this.createZoomableMap(this.width, this.height, this.showlayers);
            this.mapToSvg(data, glyphs);
            glyphs.selectAll("path").attr("d", d3.geoPath().projection(projection));
            this.colorVisualizations = ["time", "name"];
            this.currentColorVisualization = this.colorVisualizations[0];
            this.currentColorScale = d3.interpolateViridis; // Default color scale
            this.updateColorsByTime();
            this.updateColorsByName();
            enableRectangleSelection(this);
            this.lineChart = null;
            // Set up color scale selection listener
            this.setupColorScaleSelector();
        }
    
        setLinechart(lineChart) {
            this.lineChart = lineChart;
        }
    
        setupColorScaleSelector() {
            const colorScaleSelector = document.getElementById('colorScale');
    
            colorScaleSelector.addEventListener('change', (event) => {
                this.lineChart.updateGradientAndRedraw();
                const selectedScale = event.target.value;
                this.currentColorScale = d3[selectedScale]; // Dynamically assign selected color scale
                if (this.currentColorVisualization === "time") {
                    this.updateColorsByTime(); // Reapply colors using the selected scale
                }
            });
        }
    
        createZoomableMap(width, height, showlayers) {
            const svg = d3.selectAll("svg");
    
            const tile = d3.tile()
                .extent([[0, 0], [width * 3, height * 3]])
                .tileSize(512)
                .clampX(false);
    
            const rasterLevels = svg.append("g")
                .attr("pointer-events", "none")
                .selectAll("g")
                .data(deltas)
                .join("g")
                .style("opacity", showlayers ? 0.3 : null)
                // .style("filter", "grayscale(100%)")
                .classed("raster", true);
    
            glyphs = svg.append("g");
            regions = svg.append("g");
            rects = svg.append("g");
    
            const zoom = d3.zoom()
                .scaleExtent([1 << 20.5, 1 << 28])
                .extent([[0, 0], [width, height]])
                .on("zoom", (event) => zoomed(event.transform));
    
            svg
                .call(zoom)
                .call(zoom.transform, this.initialTransform)
                .on("click", (event) => {
                    const [x, y] = d3.pointer(event);
                    const [lon, lat] = projection.invert([x, y]);
                    console.log(`Latitude: ${lat}, Longitude: ${lon}`);
                });
    
    
            function zoomed(transform) {
                // Log current translation and scale values
                /*console.log("Current X Translation:", transform.x);
                console.log("Current Y Translation:", transform.y);
                console.log("Current Scale (Zoom Level):", transform.k);*/
    
                projection
                    .scale(transform.k / tau)
                    .translate([transform.x, transform.y]);
    
                // Copy of updateGlyphs function
                updateGlyphs();
    
                regions.selectAll("polygon")
                    .attr("points", function (d) {
                        var newCoords = [];
                        for (var i = 0; i < d.geometry.coordinates[0].length; i++) {
                            newCoords.push(projection(d.geometry.coordinates[0][i]));
                        }
                        return newCoords.map(coord => coord.join(",")).join(" ");
                    });
    
                rasterLevels.each(function (delta) {
                    const tiles = tile.zoomDelta(delta)(transform);
    
                    d3.select(this)
                        .selectAll("image")
                        .data(tiles, d => d)
                        .join("image")
                        .attr("xlink:href", d => url(...d3.tileWrap(d)))
                        .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
                        .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
                        .attr("width", tiles.scale)
                        .attr("height", tiles.scale);
                });
            }
    
        }
    
        mapToSvg(data, glyphs) {
            var svgPoints = glyphs.selectAll("path").data(data, d => d.properties.name);
            svgPoints.exit().remove();
            svgPoints.enter()
                .append("path")
                .attr("datum", function (d) { return d; })
                .attr("d", path)
                .attr("fill", d => colorScale(d.properties.date))
                .on("mouseover", (event, d) => this.showTooltip(event, d))
                .on("mouseout", (event, d) => this.hideTooltip())
                .on("click", (event, d) => this.onGlyphClick(event, d));
    
            updateGlyphs();
        }
    
        // Tooltip methods
        showTooltip(event, d) {
            if (d.properties.selected) { // Only show tooltip if the point is selected
                const format = d3.timeFormat("%m/%d/%Y %H:%M");
                const tooltip = d3.select("#tooltip");
                const content = this.currentColorVisualization === "time" ? d.properties.name : format(d.properties.date);
                tooltip.style("display", "block")
                    .html(content)
                    .style("left", `${event.pageX + 5}px`)
                    .style("top", `${event.pageY + 5}px`);
            }
        }
    
    
        hideTooltip() {
            d3.select("#tooltip").style("display", "none");
        }
    
        addItem() {
            var point = ["Feature " + featureId++, 14.24 + Math.random() * 0.04, 50.09 + Math.random() * 0.01];
            data.push(this.toGeoPoint(point));
            this.mapToSvg(data, glyphs);
            glyphs.selectAll("path").attr("d", d3.geoPath().projection(projection));
        }
    
        updateColorsByTime() {
            const filteredData = data.filter(d => d.properties.selected === true);
    
            colorScale = d3.scaleSequential(this.currentColorScale)
                .domain(dateSpan);
    
            glyphs.selectAll("path")
                .attr("fill", d => colorScale(d.properties.date));
    
            this.displayColorScale();
        }
    
        updateColorsByName(names) {
            //const predefinedColors = d3.schemeCategory10;
            /*const colorMapping = {};
    
            const uniqueNames = [...new Set(data.map(d => d.properties.name))];
            uniqueNames.forEach((name, index) => {
                colorMapping[name] = predefinedColors[index % predefinedColors.length];
            });
    */
            glyphs.selectAll("path")
                .attr("fill", d => colorMapping[d.properties.name] || "black");
    
            //this.displayUniqueNames(colorMapping, names);
        }
    
        applyUpdates(names) {
            //console.log("Applying updates");
            //console.log(this.currentColorVisualization);
            if (this.currentColorVisualization === "time") {
                //console.log("UpdatingByTime");
                this.updateColorsByTime();
            } else if (this.currentColorVisualization === "name") {
                this.updateColorsByName(names);
            }
    
            //selected glyphs are highlighted
            updateGlyphs();
        }
    
        displayColorScale() {
            const colorScaleDiv = document.getElementById("color-scale");
            colorScaleDiv.innerHTML = ""; // Clear existing content
    
            // Set the fixed width for the container div
            const fixedWidth = 400; // Adjust this value as needed
            colorScaleDiv.style.width = `${fixedWidth}px`;
            colorScaleDiv.style.overflow = "hidden"; // Optional: to prevent overflow
            colorScaleDiv.style.display = "flex"; // For horizontal layout
    
            // Filter data based on the selected property
            const selectedData = data.filter(d => d.properties.selected === true);
    
            // Check if there is any selected data
            if (selectedData.length === 0) {
                console.warn("No selected data found.");
                return;
            }
    
            // Format for displaying dates
            const formatDate = d3.timeFormat("%m/%d/%Y");
    
            // Get the start and end dates from the global dateSpan
            const startDate = new Date(dateSpan[0]);
            const endDate = new Date(dateSpan[1]);
            const startDateFormatted = formatDate(startDate);
            const endDateFormatted = formatDate(endDate);
    
            // Create and style the start and end date divs
            const startDateDiv = document.createElement("div");
            startDateDiv.textContent = startDateFormatted;
            startDateDiv.style.marginLeft = "5px";
            startDateDiv.style.width = "auto";
            startDateDiv.style.height = "auto";
    
            const endDateDiv = document.createElement("div");
            endDateDiv.textContent = endDateFormatted;
            endDateDiv.style.marginLeft = "5px";
            endDateDiv.style.width = "auto";
            endDateDiv.style.height = "auto";
    
            // Append the start date div to the color scale container
            colorScaleDiv.appendChild(startDateDiv);
    
            // Sort the selected data by date to ensure a continuous scale
            const sortedData = selectedData.sort((a, b) => new Date(a.properties.date) - new Date(b.properties.date));
    
            // Calculate dynamic width for each color segment div
            const segmentWidth = Math.floor(fixedWidth / sortedData.length);
    
            // Map each selected data entry to a normalized color within dateSpan
            sortedData.forEach((d, i) => {
                const date = new Date(d.properties.date);
                // Normalize the date within the dateSpan range
                const normalizedValue = (date - startDate) / (endDate - startDate);
                const color = this.currentColorScale(normalizedValue); // Apply color scale
    
                const div = document.createElement("div");
                div.style.backgroundColor = color;
                div.style.height = "10px"; // Adjust height as needed
                div.style.width = `${segmentWidth}px`; // Set dynamic width for each segment
                div.addEventListener("mouseover", (event) => this.showColorScaleTooltip(event, color, i));
                div.addEventListener("mouseout", () => this.hideTooltip());
                colorScaleDiv.appendChild(div);
            });
    
            // Append the end date div to the color scale container
            colorScaleDiv.appendChild(endDateDiv);
        }
    
    
    
    
    
        showColorScaleTooltip(event, color, i) {
            const tooltip = d3.select("#tooltip");
    
            // Retrieve the date directly from the sortedData array
            const selectedData = data.filter(d => d.properties.selected === true);
            const sortedData = selectedData.sort((a, b) => new Date(a.properties.date) - new Date(b.properties.date));
            const date = new Date(sortedData[i].properties.date); // Get the date of the current segment
    
            const format = d3.timeFormat("%m/%d/%Y %H:%M");
            const formattedDate = format(date);
    
            tooltip.style("display", "block")
                .html(`Date: ${formattedDate}`)
                .style("left", `${event.pageX + 5}px`)
                .style("top", `${event.pageY + 5}px`);
        }
    
    
        displayUniqueNames(colorMapping, uniqueNames) {
            const uniqueNamesDiv = document.getElementById("unique-names");
            uniqueNamesDiv.innerHTML = "";
    
            uniqueNames.forEach(name => {
                const nameDiv = document.createElement("div");
                nameDiv.style.backgroundColor = colorMapping[name];
                nameDiv.style.color = "white";
                nameDiv.style.position = "relative";
                nameDiv.style.display = "inline-block";
                nameDiv.style.padding = "5px";
                //nameDiv.style.margin = "5px";
                nameDiv.style.marginLeft = "5px";
                nameDiv.style.borderRadius = "5px";
                nameDiv.style.cursor = "pointer";
    
                nameDiv.textContent = name;
    
                const removeSpan = document.createElement("span");
                removeSpan.className = 'remove';
                removeSpan.style.position = "absolute";
                removeSpan.style.top = "0";
                removeSpan.style.right = "0";
                removeSpan.style.width = "16px";
                removeSpan.style.height = "16px";
                removeSpan.style.backgroundColor = "rgb(87, 24, 24)";
                removeSpan.style.color = "rgb(255, 255, 255)";
                removeSpan.style.textAlign = "center";
                removeSpan.style.lineHeight = "16px";
                removeSpan.style.borderRadius = "50%";
                removeSpan.style.cursor = "pointer";
                removeSpan.style.display = "none";
                removeSpan.textContent = 'X';
    
                removeSpan.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent triggering parent click
                    const indexToRemove = uniqueNames.indexOf(name);
                    uniqueNames.splice(indexToRemove, 1); // Remove name from uniqueNames array
                    nameDiv.remove(); // Remove the nameDiv from the DOM
    
                    if (uniqueNames.length === 0) {
                        const noEventsDiv = document.createElement("div");
                        noEventsDiv.textContent = "No events selected";
                        uniqueNamesDiv.appendChild(noEventsDiv);
                    }
    
                    document.querySelector(`.checkbox-group input[type="checkbox"][value="${name}"]`).checked = false;
                    updateSelectAllButtonText();
                    updateSelectedEvents();
                    const filters = getFilters();
                    applyFilters(filters);
                    showActiveFilters(filters);
    
                });
    
                nameDiv.appendChild(removeSpan);
    
                nameDiv.addEventListener('mouseover', () => {
                    removeSpan.style.display = "block";
                });
    
                nameDiv.addEventListener('mouseout', () => {
                    removeSpan.style.display = "none";
                });
    
                uniqueNamesDiv.appendChild(nameDiv);
            });
    
            if (uniqueNames.length === 0) {
                const div = document.createElement("div");
                div.textContent = "No events selected";
                uniqueNamesDiv.appendChild(div);
            }
    
            //document.getElementById("color-scale").style.display = "none";
            uniqueNamesDiv.style.display = "block";
        }
    
        // Function to handle glyph click
        onGlyphClick(event, d) {
            if (checkIfPointPassesFilter(d)) {
                d.properties.highlighted = !d.properties.highlighted;
                //d.properties.selected = d.properties.highlighted;
                this.highlightTableWithId(d.properties.id);
                //lineChart.updateChartData(dataHandler.getHighlightedEventCounts().eventCounts);
                updateHighlightedSubcharts();
                updateGlyphs();
            }
        }
    
        // Placeholder function to be called with glyph id
        highlightTableWithId(id) {
            //console.log(`Function called with id: ${id}`);
            // Add your custom logic here
            //find a html element with the id
            var element = document.getElementById(id);
            //toggle class highlighted
            element.classList.toggle("highlighted");
        }
    
    
    }
    
}
selection.js
{
    function enableRectangleSelection(zoomableMap) {
        const svg = d3.select("#map");
        let startPoint, endPoint, selectionRect;
        
        svg.on("mousedown", (event) => {
            if (event.button === 2) { // Check if right mouse button is pressed
                event.preventDefault();
                startPoint = d3.pointer(event);
                if (selectionRect) {
                    selectionRect.remove();
                }
                selectionRect = svg.append("rect")
                    .attr("x", startPoint[0])
                    .attr("y", startPoint[1])
                    .attr("width", 0)
                    .attr("height", 0)
                    .attr("fill", "rgba(0, 0, 255, 0.3)")
                    .attr("stroke", "blue")
                    .attr("stroke-width", 1);
    
                svg.on("mousemove", mousemoveHandler);
            }
        });
    
        function mousemoveHandler(event) {
            if (startPoint) {
                endPoint = d3.pointer(event);
                const x = Math.min(startPoint[0], endPoint[0]);
                const y = Math.min(startPoint[1], endPoint[1]);
                const width = Math.abs(startPoint[0] - endPoint[0]);
                const height = Math.abs(startPoint[1] - endPoint[1]);
                selectionRect
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", width)
                    .attr("height", height);
            }
        }
    
        svg.on("mouseup", (event) => {
            if (event.button === 2 && startPoint) { // Check if right mouse button is released
                endPoint = d3.pointer(event);
                const x0 = Math.min(startPoint[0], endPoint[0]);
                const y0 = Math.min(startPoint[1], endPoint[1]);
                const x1 = Math.max(startPoint[0], endPoint[0]);
                const y1 = Math.max(startPoint[1], endPoint[1]);
        
                const filters = getFilters();
                let somethingSelected = true;
                lineChart.clearBrush();
                for (var i = 0; i < lineChart.subLineCharts.length; i++) {
                    lineChart.subLineCharts[i].clearBrush();
                }
                // Check if it was a single right-click (no drag)
                const isSingleClick = (x0 === x1 && y0 === y1);
        
                if (isSingleClick) {
                    // Unhighlight only the points that pass the filter (i.e., points that are selected)
                    glyphs.selectAll("path").each(function (d) {
                        const element = document.getElementById(d.properties.id);
                        if (element && d.properties.highlighted && d.properties.selected) {
                            d.properties.highlighted = false;
                            element.classList.remove("highlighted");
                        }
                    });
                    console.log("linechart", lineChart);
                    
                    console.log("Unhighlighted filtered points due to single right-click.");
                } else {
                    // Iterate over all glyphs for rectangle selection
                    glyphs.selectAll("path").each(function (d) {
                        const [gx, gy] = projection([d.geometry.coordinates[0], d.geometry.coordinates[1]]);
                        const element = document.getElementById(d.properties.id);
        
                        if (element) {
                            // Check if the glyph is within the selection rectangle
                            if (gx >= x0 && gx <= x1 && gy >= y0 && gy <= y1) {
                                if (checkIfPointPassesFilter(d)) {
                                    d.properties.selected = true;
                                    // Add to highlights without overriding existing ones
                                    if (!d.properties.highlighted) {
                                        d.properties.highlighted = true;
                                        element.classList.add("highlighted");
                                    }
                                }
                            } else {
                                // Unhighlight only if the point passes the filter (is selected)
                                if (checkIfPointPassesFilter(d) && d.properties.highlighted && d.properties.selected) {
                                    //d.properties.highlighted = false;
                                    element.classList.remove("highlighted");
                                }
                            }
                        }
                    });
                    console.log("Updated highlights based on rectangle selection.");
                }
        
                // Update glyphs and subcharts
                updateGlyphs();
                updateHighlightedSubcharts();
        
                // Reset the selection rectangle and event handlers
                startPoint = null;
                if (selectionRect) {
                    selectionRect.remove();
                    selectionRect = null;
                }
                svg.on("mousemove", null);
            }
            highlightTableRows();
        });
        
    
        // Prevent the default context menu from appearing
        svg.on("contextmenu", (event) => {
            event.preventDefault();
        });
        
    }
    
    
    function checkIfPointPassesFilter(point) {
        const filters = getFilters();
        let startDate, endDate;
    
        if (filters.timeFilter === 'past-7-days') {
            endDate = new Date();
            startDate = new Date();
            startDate.setDate(endDate.getDate() - 7);
        } else if (filters.timeFilter === 'past-30-days') {
            endDate = new Date();
            startDate = new Date();
            startDate.setDate(endDate.getDate() - 30);
        } else if (filters.timeFilter === 'custom') {
            startDate = filters.startDate ? new Date(filters.startDate) : null;
            endDate = filters.endDate ? new Date(filters.endDate) : null;
        }
    
        const eventName = point.properties.name;
        const eventDate = new Date(point.properties.date);
    
        const nameMatches = filters.eventTypes.includes(eventName);
        const dateMatches = (!startDate || eventDate >= startDate) && (!endDate || eventDate <= endDate);
    
        return nameMatches && dateMatches;
    }
    
    
    function updateHighlightedSubcharts() {
        // console.log("Updating highlighted subcharts");
        // console.log("available subcharts: ", lineChart.subLineCharts);
        populateEventSelection();
        //updateOrderOfLineCharts(); // Update the line charts based on the selected checkboxes
        //go through data and see if any of them is selected and highlited at the same time if yes somethingSelected is true
        var somethingIsHighlighted = dataHandler.isAnythingHighlighted();
    
    
        if (somethingIsHighlighted) {
            lineChart.clearBrush();
            lineChart.updateChartDataHighlight(dataHandler.getHighlightedEventCounts().eventCounts);
            //updateOrderOfLineCharts();
            // Update subLineCharts
            for (var i = 0; i < lineChart.subLineCharts.length; i++) {
                
                //console.log("Updating Max Y value: ", maxYValue);
                lineChart.subLineCharts[i].clearBrush();
                lineChart.subLineCharts[i].updateChartDataHighlight(dataHandler.getHighlightedEventCountsByType(lineChart.subLineCharts[i].eventType).eventCounts);
                
            }
        } else {
            lineChart.clearBrush();
            lineChart.updateChartDataHighlight(dataHandler.getHighlightedEventCounts().eventCounts);
            for (var i = 0; i < lineChart.subLineCharts.length; i++) {
                //console.log("Updating Max Y value: ", maxYValue);
                lineChart.subLineCharts[i].clearBrush();
                lineChart.subLineCharts[i].updateChartDataHighlight(dataHandler.getHighlightedEventCountsByType(lineChart.subLineCharts[i].eventType).eventCounts);
                
            }
        }
        updateMaxYValue();
    }
    
    function updateHighlightedSubchartsAfterSort()
    {
        var somethingIsHighlighted = dataHandler.isAnythingHighlighted();
    
        if (somethingIsHighlighted) {
            lineChart.clearBrush();
            lineChart.updateChartDataHighlight(dataHandler.getHighlightedEventCounts().eventCounts);
            //updateOrderOfLineCharts();
            // Update subLineCharts
            for (var i = 0; i < lineChart.subLineCharts.length; i++) {
                
                lineChart.subLineCharts[i].clearBrush();
                lineChart.subLineCharts[i].updateChartDataHighlight(dataHandler.getHighlightedEventCountsByType(lineChart.subLineCharts[i].eventType).eventCounts);
                //console.log("Max Y value: ", maxYValue);
                
            }
        } else {
            lineChart.clearBrush();
            lineChart.updateChartDataHighlight(dataHandler.getHighlightedEventCounts().eventCounts);
            for (var i = 0; i < lineChart.subLineCharts.length; i++) {
                lineChart.subLineCharts[i].clearBrush();
                lineChart.subLineCharts[i].updateChartDataHighlight(dataHandler.getHighlightedEventCountsByType(lineChart.subLineCharts[i].eventType).eventCounts);
                
            }
        }
        updateMaxYValue();
    }
    
    //recalculate and change max y value for all subcharts
    function updateMaxYValue()
    {
        //console.log("Updating max y value");
    
        maxYValue = 0;
        for (var i = 0; i < lineChart.subLineCharts.length; i++) {
            //console.log("Tadzy");
            //console.log(lineChart.subLineCharts[i].getMaxYValue());
            if (lineChart.subLineCharts[i].getMaxYValue() > maxYValue) {
                //console.log("Actually updating max y value");
                maxYValue = lineChart.subLineCharts[i].getMaxYValue();
            }
        }
        //console.log("Max Y value: ", maxYValue);
        //change max y value for all subcharts
        changeMaxYBasedOnCurrentDatespan()
        /*for (var i = 0; i < lineChart.subLineCharts.length; i++) {
            lineChart.subLineCharts[i].changeYAxisRange(maxYValue);
        }*/
    }
    
    
}
table.js
{
    const get = (obj, ...selectors) =>
        [...selectors].map(s =>
            s
                .replace(/\[([^\[\]]*)\]/g, '.$1.')
                .split('.')
                .filter(t => t !== '')
                .reduce((prev, cur) => prev && prev[cur], obj)
        );
    
    
    
    function removeItem(index) {
        //console.log(index);
        data.splice(index, 1);
        //data.pop();
        //vector.attr("d", path);
        zoomableMap.mapToSvg(data, glyphs);
        tabulate(data, tableInfo);
        updateHighlightedSubcharts();
    }
    
    function formatDate(date) {
        const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
        return new Date(date).toLocaleDateString('en-US', options);
    }
    
    function formatCoordinates(coord) {
        const num = parseFloat(coord);
        return isNaN(num) ? coord : num.toFixed(5);  // Limit to 5 decimal places
    }
    
    function tabulate(data, columns) {
        const table = d3.select('table');
        const thead = table.select('thead');
        const tbody = table.select('tbody');
    
        // Clear existing table headers and rows
        thead.selectAll('.firstTR').remove();
        thead.selectAll('.filter-row').remove();
        tbody.selectAll('tr').remove();
    
        // Append the header row with meaningful names
        const headerRow = thead.append('tr')
            .attr('class', 'firstTR')
            .selectAll('th')
            .data(columns)
            .enter()
            .append('th')
            .attr('data-column', column => column)
            .text(column => {
                switch (column) {
                    case "properties.name": return "Type";
                    case "properties.date": return "Date";
                    case "geometry.coordinates[0]": return "Longitude";
                    case "geometry.coordinates[1]": return "Latitude";
                    default: return column;
                }
            })
            .on('click', function (event, column) {
                sortTableByColumn(column);
            });
    
        // Add empty sort icons initially
        headerRow.append('span')
            .attr('class', 'sort-icon')
            .text('');
    
        updateTableBody(data, columns);
    }
    
    let sortOrder = {}; // Track sort order for each column
    
    function sortTableByColumn(column) {
        console.log(`Sorting by column: ${column}`);
    
        // Determine the current sort order for the column
        if (!sortOrder[column]) {
            sortOrder[column] = 'asc'; // Default to ascending if not sorted before
        } else {
            sortOrder[column] = sortOrder[column] === 'asc' ? 'desc' : 'asc';
        }
    
        //console.log(`Sort order for column "${column}": ${sortOrder[column]}`);
    
        // Remove previous highlights and icons
        d3.selectAll('th')
            .classed('sorted', false)
            .select('.sort-icon')
            .text('');
    
        // Highlight the active column and update the icon
        d3.select(`th[data-column="${column}"]`)
            .classed('sorted', true)
            .select('.sort-icon')
            .text(sortOrder[column] === 'asc' ? ' ▲' : ' ▼'); // Unicode for up/down arrows
    
        // Sort the data based on the selected column and order
        data.sort((a, b) => {
            const aValue = get(a, column);
            const bValue = get(b, column);
    
            let aComparable = aValue;
            let bComparable = bValue;
    
            // Check if the column is the "properties.date" column and parse the date
            if (column === "properties.date") {
                aComparable = new Date(aValue);
                bComparable = new Date(bValue);
            }
    
            //console.log(`Comparing values: a="${aComparable}", b="${bComparable}"`);
    
            if (aComparable < bComparable) {
                return sortOrder[column] === 'asc' ? -1 : 1;
            }
            if (aComparable > bComparable) {
                return sortOrder[column] === 'asc' ? 1 : -1;
            }
            return 0;
        });
    
        //console.log('Sorted data:', data);
    
        updateTableBody(data, tableInfo);
    }
    
    
    
    
    
    
    function toggleHighlightData(d) {
        //console.log("toggleHighlight");
        //console.log(d);
    
        d.properties.highlighted = !d.properties.highlighted;
        //d.properties.selected = d.properties.highlighted;
        lineChart.updateChartDataHighlight(dataHandler.getHighlightedEventCounts().eventCounts);
        for (var i = 0; i < lineChart.subLineCharts.length; i++) {
            lineChart.subLineCharts[i].updateChartDataHighlight(dataHandler.getHighlightedEventCountsByType(lineChart.subLineCharts[i].eventType).eventCounts);
        }
        updateGlyphs();
    }
    
    function toggleHighlightRow(row) {
        console.log("toggleHighlightRow");
        // Check if the row has the 'highlighted' class
        if (d3.select(row).classed('highlighted')) {
            // If it does, remove the 'highlighted' class
            d3.select(row).classed('highlighted', false);
        } else {
            // If it doesn't, add the 'highlighted' class
            d3.select(row).classed('highlighted', true);
        }
    }
    
    function highlightTableRows() {
        console.log("highlightTableRows");
        const tbody = d3.select('table').select('tbody');
        data.forEach(d => {
            const rowId = d.properties.id;
            const isHighlighted = d.properties.highlighted;
            //select tr with id
            const row = tbody.select(`tr[id="${rowId}"]`);
    
            if (isHighlighted) {
                row.classed('highlighted', true);
            } else {
                row.classed('highlighted', false);
            }
        });
    }
    
    
    
    function updateHighlightedPoints() {
        // Implement the logic to update the map visualization
        // based on the highlighted property of data points
        // For example:
        zoomableMap.mapToSvg(data, glyphs);
    }
    
    function updateTableBody(data, columns) {
        console.log("Updating table body...");
        console.log("Data to render:", data);
    
        const tbody = d3.select('table').select('tbody');
    
        // Bind data to rows, using the unique 'properties.id' as the key
        const rows = tbody.selectAll('tr')
            .data(data, d => d && d.properties ? d.properties.id : null);
    
        // Remove any rows that no longer have matching data
        rows.exit().remove();
    
        // Append new rows for incoming data
        const addedRows = rows.enter().append('tr')
            .attr('id', d => d && d.properties ? d.properties.id : null)
            .on('click', function (event, d) {
                toggleHighlightData(d);
                toggleHighlightRow(this);
                updateHighlightedSubcharts();
            });
    
        // Merge new and existing rows and reorder them in the DOM
        const allRows = addedRows.merge(rows)
            .order() // Ensure rows are rendered in the order of the bound data
            .attr('id', d => d && d.properties ? d.properties.id : null);
    
        console.log("Rows after merge:", allRows);
    
        // Update the cells within each row
        const cells = allRows.selectAll('td')
            .data(function (row) {
                return columns.map(function (column) {
                    let value = get(row, column);
                    if (column === "properties.date") {
                        value = formatDate(value);
                    } else if (column === "geometry.coordinates[0]" || column === "geometry.coordinates[1]") {
                        value = formatCoordinates(value);
                    }
                    return { column: column, value: value };
                });
            });
    
        // Remove any old cells
        cells.exit().remove();
    
        // Append new cells for incoming data
        cells.enter()
            .append('td')
            .merge(cells) // Merge with existing cells
            .text(d => d.value);
    
        // Apply the 'highlighted' class to rows based on the 'highlighted' property
        allRows.classed('highlighted', d => d && d.properties ? d.properties.highlighted : false);
    
        console.log("Table body updated.");
    }
    
    
    function updateTableWithFilteredData() {
        // Filter the data to only include items where properties.selected is true
        const filteredData = data.filter(d => d.properties.selected);
    
        // Now call updateTableBody with the filtered data
        updateTableBody(filteredData, tableInfo);
        //console.log("Updating");
        updateHighlightedSubcharts();
    }
    
    
    
}

index.html
{
    <!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airport data visualization</title>

    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/mapStyle.css">
    <link rel="stylesheet" href="css/filters.css">
    <link rel="stylesheet" href="css/table.css">
    <link rel="stylesheet" href="css/linechart.css">
    <link rel="stylesheet" href="css/toggleButton.css">
    <link rel="stylesheet" href="css/brush.css">
    <link rel="stylesheet" href="css/colors.css">

    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://d3js.org/d3.v6.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>



    <script src="js/dataHandling/data.js"></script>
    <script src="js/linechart/linechart.js"></script>
    <script src="js/linechart/subLineChart.js"></script>
    <script src="js/dataHandling/dataArray.js"></script>
    <script src="js/dataFiltering/dataFiltering.js"></script>
    <script src="js/constants/constants.js"></script>
    <script src="js/map/map.js"></script>
    <script src="js/map/selection.js"></script>
    <script src="js/table/table.js"></script>

</head>

<body>
    <script>

    </script>
    <div class="container">
        <div class="column column-1">
            <div class="row data-filters block">
                <div class="name-time">
                    <div class="filterHeader">Choose visualization type</div>
                    <div class="change-name-time" id="change-name-time">
                        <input type="radio" id="time" name="visualization" value="time" checked>
                        <label for="time">By time</label>
                        <input type="radio" id="name" name="visualization" value="name">
                        <label for="name">By type</label>
                    </div>
                    <div id="color-visualization" style="display:none;">
                        <div id="color-scale" class="color-scale"></div>
                        <div class="color-scale-selector">
                            <div class="center-label">Choose Color Scale:</div>
                            <select id="colorScale">
                                <option value="interpolateInferno">Inferno</option>
                                <option value="interpolateViridis">Viridis</option>   
                                <option value="interpolateMagma">Magma</option>
                                <option value="interpolatePlasma">Plasma</option>
                                <option value="interpolateCividis">Cividis</option>
                                <option value="interpolateCool">Cool</option>
                                <option value="interpolateWarm">Warm</option>
                                <option value="interpolateCubehelixDefault">Cubehelix</option>
                                <!-- <option value="interpolateRainbow">Rainbow</option>
                                <option value="interpolateSinebow">Sinebow</option> -->
                            </select>
                        </div>
                    </div>
                </div>

                <div class="filter">
                    <div class="filterHeader">Choose time and events types</div>
                    <div class="filterBox">
                        <label for="time-filter">Filter by Time:</label>
                        <div class="time-filter">
                            <select id="time-filter" name="time">
                                <option value="past-7-days">Last 7 Days</option>
                                <option value="past-30-days" selected>Last 30 Days</option>
                                <option value="custom">Custom</option>
                            </select>
                            <div class="custom-time" id="custom-time">
                                <label for="start-date">From</label>
                                <input type="date" id="start-date" name="start-date">
                                <label for="end-date">To</label>
                                <input type="date" id="end-date" name="end-date">
                            </div>
                        </div>
                    </div>
                    <div class="filterBox">
                        <label for="event-type">Filter by Event Type:</label>
                        <div id="dropdown" class="dropdown-content">
                            <div class="search-select-container">
                                <input type="text" id="search-event-types" placeholder="Search event types...">

                            </div>
                            <div class="hide-group">
                                <div class="checkbox-group">
                                </div>
                                <div class="button-group">
                                    <button id="confirm-selection">OK</button>
                                    <button id="select-all" class="select-all-button">Select All</button>
                                    <button id="reset-filters">Reset Filters</button>
                                </div>
                            </div>

                        </div>
                    </div>
                    <div id="active-filters" class="active-filters">
                        <h3>Active Filters:</h3>
                        <p id="active-time-filter">Time Filter: None</p>
                        <p id="active-event-types">Event Types: None</p>
                    </div>

                </div>
            </div>

            <div class="row table-row block">
                <div class="table-container">

                    <table>
                        <thead></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <script>

                    // console.log("Data for the table");
                    // console.log(data);
                    tabulate(data, tableInfo);</script>
            </div>

        </div>
        <div class="column column-2">
            <div class="row row-1 block">
                <div id="brush-tooltip" class="brush-tooltip"></div>
                <div id="my_dataviz"><span class="mainChart-label">
                        <div class="toggleButtonWrapper">
                            <button id="toggleButton">See More</button>
                            <div id="eventSelection">
                                <!-- Dynamically populated checkboxes will go here -->
                            </div>
                        </div>
                    </span>
                </div>

                <div id="hiddenCharts" class="hidden">
                    <div class="text-block">Text Block 1</div>
                    <div class="text-block">Text Block 2</div>
                    <div class="text-block">Text Block 3</div>
                </div>
                <div id="fixed-labels-container" class="hidden"></div>
            </div>
            <div class="row row-2 block">

                <svg id="map"></svg>
                <div id="tooltip"></div>
                <script>
                    zoomableMap = new ZoomableMap();
                    sortTableByColumn("properties.name");
                </script>
            </div>
        </div>
    </div>
    <script src="js/linechart/seeMoreLinecharts.js"></script>
    <!-- <script src="js/linechart/popup.js"></script> -->
</body>

</html>
}

data.js{
class DataClass {
    constructor(N, nameArray, latRange, lonRange, nameWeights = null, latLonWeights = null, seed = null) {
        this.N = N;
        this.nameArray = nameArray;
        this.latRange = latRange;
        this.lonRange = lonRange;
        this.nameWeights = nameWeights || new Array(nameArray.length).fill(1); // Default equal weighting if none provided
        this.latLonWeights = latLonWeights || [1, 1]; // Default equal weight for lat/lon ranges
        this.seed = seed || Math.random().toString(); // Generate random seed if not provided
        this.dateSpan = dateSpan; // Add dateSpan as a class property
        this.rng = new Math.seedrandom(this.seed); // Create a seeded random number generator
        this.data = generatedData;
        // console.log("generatedData: ", generatedData);
    }

    getData() {
        return this.data;
    }

    getNames() {
        return this.nameArray;
    }

    getLatitudeRange() {
        return this.latRange;
    }

    getLongitudeRange() {
        return this.lonRange;
    }


    generateDateRange() {
        const dates = [];
        let currentDate = new Date(this.dateSpan[0]);
        const endDate = new Date(this.dateSpan[1]);

        while (currentDate <= endDate) {
            dates.push(new Date(currentDate)); // Add a copy of the date
            currentDate.setDate(currentDate.getDate() + 1);
        }

        return dates;
    }


    // Modified fillMissingDates to handle eventCounts directly
    fillMissingDates(eventCounts, eventType, eventTypeProportions = null) {
        const dateRange = this.generateDateRange();
        //console.log("eventCounts: ", eventCounts);
    
        const optimizedEventCounts = [];
        let previousValue = 0;
        let previousEventTypeProportions = {};
    
        dateRange.forEach(date => {
            const dateString = date.toISOString().split('T')[0];
            const event = eventCounts.find(count => count.date.toISOString().split('T')[0] === dateString);
    
            let currentTime = new Date(date);
            currentTime.setHours(0, 0, 0, 0); // Start at the beginning of the day
    
            const eventValue = event ? event.value : 0;
            const currentEventTypeProportions = eventTypeProportions ? eventTypeProportions.find(e => e.date.toISOString().split('T')[0] === dateString)?.types || {} : {};
    
            // Check for transitions in value or event type proportions
            if (eventValue !== previousValue || JSON.stringify(currentEventTypeProportions) !== JSON.stringify(previousEventTypeProportions)) {
                // Add a transition point right before the change for sharpness
                optimizedEventCounts.push({
                    date: new Date(currentTime.getTime() - 1),
                    value: previousValue,
                    eventType: eventType,
                    eventTypeProportions: previousEventTypeProportions
                });
    
                optimizedEventCounts.push({
                    date: new Date(currentTime),
                    value: eventValue,
                    eventType: eventType,
                    eventTypeProportions: currentEventTypeProportions
                });
            }
    
            // Keep value the same throughout the day with start and end points
            optimizedEventCounts.push({
                date: new Date(currentTime),
                value: eventValue,
                eventType: eventType,
                eventTypeProportions: currentEventTypeProportions
            });
    
            let endOfDay = new Date(currentTime);
            endOfDay.setHours(23, 59, 59, 999);
            optimizedEventCounts.push({
                date: endOfDay,
                value: eventValue,
                eventType: eventType,
                eventTypeProportions: currentEventTypeProportions
            });
    
            previousValue = eventValue;
            previousEventTypeProportions = currentEventTypeProportions;
        });
    
        // Remove leading and trailing zero-value data points for cleaner output
        let start = 0;
        while (start < optimizedEventCounts.length && optimizedEventCounts[start].value === 0) {
            start++;
        }
    
        let end = optimizedEventCounts.length - 1;
        while (end >= 0 && optimizedEventCounts[end].value === 0) {
            end--;
        }
    
        //console.log(`Optimized event counts for eventType "${eventType}":`, optimizedEventCounts);
        return optimizedEventCounts.slice(start, end + 1);
    }
    
    
    

    getSelectedEventCounts() {
        const selectedEvents = this.data.filter(event => event.properties.selected);
        const eventCounts = {};
        const eventTypeCounts = {}; // Object to store counts per event type
    
        selectedEvents.forEach(event => {
            const date = event.properties.date.toISOString().split('T')[0];
            const eventType = event.properties.name;
    
            // Initialize the count for the date if not already done
            if (!eventCounts[date]) {
                eventCounts[date] = 0;
                eventTypeCounts[date] = {};
            }
    
            // Increment the total count for the date
            eventCounts[date]++;
    
            // Increment the count for the specific event type
            eventTypeCounts[date][eventType] = (eventTypeCounts[date][eventType] || 0) + 1;
        });
    
        // Convert eventCounts and eventTypeCounts to arrays
        const eventCountsArray = Object.keys(eventCounts).map(date => ({
            date: new Date(date),
            value: eventCounts[date]
        }));
    
        const eventTypeProportions = Object.keys(eventTypeCounts).map(date => ({
            date: new Date(date),
            types: eventTypeCounts[date] // Contains counts for each event type
        }));
    
        return {
            eventCounts: this.fillMissingDates(eventCountsArray, "All events", eventTypeProportions),
            eventTypeProportions: eventTypeProportions,
            activeEventTypes: Array.from(new Set(selectedEvents.map(event => event.properties.name)))
        };
    }
    

   

    getHighlightedEventCounts() {
        updateGlyphs();
        const highlightedEvents = this.data.filter(event => event.properties.highlighted);
        const eventCounts = {};
        const eventTypeCounts = {}; // Object to store counts per event type
    
        highlightedEvents.forEach(event => {
            const date = event.properties.date.toISOString().split('T')[0];
            const eventType = event.properties.name;
    
            // Initialize the count for the date if not already done
            if (!eventCounts[date]) {
                eventCounts[date] = 0;
                eventTypeCounts[date] = {};
            }
    
            // Increment the total count for the date
            eventCounts[date]++;
    
            // Increment the count for the specific event type
            eventTypeCounts[date][eventType] = (eventTypeCounts[date][eventType] || 0) + 1;
        });
    
        // Convert eventCounts and eventTypeCounts to arrays
        const eventCountsArray = Object.keys(eventCounts).map(date => ({
            date: new Date(date),
            value: eventCounts[date]
        }));
    
        const eventTypeProportions = Object.keys(eventTypeCounts).map(date => ({
            date: new Date(date),
            types: eventTypeCounts[date] // Contains counts for each event type
        }));
    
        return {
            eventCounts: this.fillMissingDates(eventCountsArray, "All events", eventTypeProportions),
            eventTypeProportions: eventTypeProportions,
            activeEventTypes: Array.from(new Set(highlightedEvents.map(event => event.properties.name)))
        };
    }
    

    getEventTypeData(eventType) {
        const filteredEvents = this.data.filter(event => event.properties.name === eventType);
        const eventCounts = {};

        filteredEvents.forEach(event => {
            const date = event.properties.date.toISOString().split('T')[0]; // Extract the date part
            if (eventCounts[date]) {
                eventCounts[date]++;
            } else {
                eventCounts[date] = 1;
            }
        });

        const eventCountsArray = Object.keys(eventCounts).map(date => ({
            date: new Date(date),
            value: eventCounts[date]
        }));

        eventCountsArray.sort((a, b) => a.date - b.date);

        return this.fillMissingDates(eventCountsArray, eventType);
    }



    getHighlightedEventCountsByType(eventType) {
        const highlightedEvents = this.data.filter(event => event.properties.highlighted && event.properties.name === eventType);
        const eventCounts = {};
        const activeEventTypes = new Set();

        highlightedEvents.forEach(event => {
            const date = event.properties.date.toISOString().split('T')[0]; // Extract the date part
            if (eventCounts[date]) {
                eventCounts[date]++;
            } else {
                eventCounts[date] = 1;
            }
            activeEventTypes.add(event.properties.name);
        });

        const eventCountsArray = Object.keys(eventCounts).map(date => ({
            date: new Date(date),
            value: eventCounts[date]
        }));

        eventCountsArray.sort((a, b) => a.date - b.date);

        return {
            eventCounts: this.fillMissingDates(eventCountsArray, eventType),
            activeEventTypes: Array.from(activeEventTypes)
        };
    }

    getSelectedEventCountsByType(eventType) {
        const selectedEvents = this.data.filter(event => event.properties.selected && event.properties.name === eventType);
        const eventCounts = {};
        const activeEventTypes = new Set();

        selectedEvents.forEach(event => {
            const date = event.properties.date.toISOString().split('T')[0]; // Extract the date part
            if (eventCounts[date]) {
                eventCounts[date]++;
            } else {
                eventCounts[date] = 1;
            }
            activeEventTypes.add(event.properties.name);
        });

        const eventCountsArray = Object.keys(eventCounts).map(date => ({
            date: new Date(date),
            value: eventCounts[date]
        }));

        eventCountsArray.sort((a, b) => a.date - b.date);

        return {
            eventCounts: this.fillMissingDates(eventCountsArray, eventType),
            activeEventTypes: Array.from(activeEventTypes)
        };
    }


    getAvailableEventTypes() {
        // Return a unique list of event types from nameArray
        return [...new Set(this.nameArray)];
    }

    //function to return if any data are highlighted at this moment
    isAnythingHighlighted() {
        for (var i = 0; i < this.data.length; i++) {
            if (this.data[i].properties.highlighted) {
                return true;
            }
        }
        return false;
    }

}

}

dataArray.js{
/**
 * Generates an array of geoJSON-like data points with complex customization.
 * @param {Array} eventNames - List of event names to be used for events.
 * @param {Array} eventDatesWithHours - List of dates with hours as ISO strings.
 * @param {boolean} allSelected - If true, all points will be selected; if false, it will be random.
 * @param {boolean} allHighlighted - If true, all points will be highlighted; if false, it will be random.
 * @param {Object} proximityConfig - An object specifying areas with dense points.
 * @param {Object} eventOccurrenceConfig - An object specifying event names and their relative frequencies.
 * @param {Object} hotspotEventWeights - An object specifying event names and their relative frequencies within hotspots.
 * @param {Object} hotspotTimeWeights - An object specifying time weights for points in hotspots.
 * @param {Object} normalTimeWeights - An object specifying time weights for points outside of hotspots.
 * @param {number} totalPoints - Total number of points to generate.
 * @param {number} hotspotProbability - Probability that a point is generated in a hotspot.
 * @returns {Array} - Array of geoJSON-like objects.
 */
// Updated generateGeoJsonData to apply fillMissingDates only once during data generation
function generateGeoJsonData({
    eventNames,
    eventDatesWithHours,
    allSelected = true,
    allHighlighted = false,
    proximityConfig = { hotspots: [{ lat: 50.09, lng: 14.25, radius: 0.01, density: 10 }] },
    eventOccurrenceConfig = { Trash: 1, Wildlife: 1, Vandalism: 1, Weather: 1, Damage: 1, Other: 1 },
    hotspotEventWeights = { Trash: 2, Wildlife: 3, Vandalism: 1 },
    hotspotTimeWeights = { "2024-10-08T12:00:00Z": 2, "2024-10-05T12:00:00Z": 1 },
    normalTimeWeights = { "2024-10-02T12:00:00Z": 2, "2024-10-07T12:00:00Z": 1 },
    totalPoints = 50,
    hotspotProbability = 0.4,
    seed = 123456
}) {
    // Seeded random number generator
    let currentSeed = seed;
    const rng = () => {
        const a = 1664525;
        const c = 1013904223;
        const m = 2 ** 32;
        currentSeed = (a * currentSeed + c) % m;
        return currentSeed / m;
    };

    const minLat = 50.08615648561272;
    const maxLat = 50.11815590532789;
    const minLng = 14.225240518215271;
    const maxLng = 14.288241809867836;

    const getRandomInt = (min, max) => Math.floor(rng() * (max - min + 1)) + min;

    const eventWeights = Object.entries(eventOccurrenceConfig).map(([key, weight]) => ({ name: key, weight }));
    const totalWeight = eventWeights.reduce((acc, item) => acc + item.weight, 0);

    const hotspotWeights = Object.entries(hotspotEventWeights).map(([key, weight]) => ({ name: key, weight }));
    const totalHotspotWeight = hotspotWeights.reduce((acc, item) => acc + item.weight, 0);

    const hotspotTimes = Object.entries(hotspotTimeWeights).map(([time, weight]) => ({ time, weight }));
    const totalHotspotTimeWeight = hotspotTimes.reduce((acc, item) => acc + item.weight, 0);

    const normalTimes = Object.entries(normalTimeWeights).map(([time, weight]) => ({ time, weight }));
    const totalNormalTimeWeight = normalTimes.reduce((acc, item) => acc + item.weight, 0);

    const getRandomEventName = (weights, totalWeight) => {
        const randomValue = rng() * totalWeight;
        let cumulativeWeight = 0;
        for (const { name, weight } of weights) {
            cumulativeWeight += weight;
            if (randomValue <= cumulativeWeight) {
                return name;
            }
        }
        return eventNames[0];
    };

    const getRandomTime = (weights, totalWeight) => {
        const randomValue = rng() * totalWeight;
        let cumulativeWeight = 0;
        for (const { time, weight } of weights) {
            cumulativeWeight += weight;
            if (randomValue <= cumulativeWeight) {
                return time;
            }
        }
        return eventDatesWithHours[0];
    };

    const getRandomCoordsWithinBounds = () => {
        const randomLat = minLat + rng() * (maxLat - minLat);
        const randomLng = minLng + rng() * (maxLng - minLng);
        return [parseFloat(randomLng.toFixed(5)), parseFloat(randomLat.toFixed(5))];
    };

    const getRandomCoordsNear = (lat, lng, radius) => {
        const randomLat = lat + (rng() - 0.5) * radius * 2;
        const randomLng = lng + (rng() - 0.5) * radius * 2;
        return [parseFloat(randomLng.toFixed(5)), parseFloat(randomLat.toFixed(5))];
    };

    const data = [];
    for (let i = 0; i < totalPoints; i++) {
        const shouldBeInHotspot = rng() < hotspotProbability && proximityConfig.hotspots && proximityConfig.hotspots.length > 0;

        const eventName = shouldBeInHotspot
            ? getRandomEventName(hotspotWeights, totalHotspotWeight)
            : getRandomEventName(eventWeights, totalWeight);

        const eventTime = shouldBeInHotspot
            ? getRandomTime(hotspotTimes, totalHotspotTimeWeight)
            : getRandomTime(normalTimes, totalNormalTimeWeight);

        const eventDate = new Date(eventTime);
        const selected = true;
        const highlighted = allHighlighted;

        let coordinates = [];
        if (shouldBeInHotspot) {
            const hotspot = proximityConfig.hotspots[getRandomInt(0, proximityConfig.hotspots.length - 1)];
            coordinates = getRandomCoordsNear(hotspot.lat, hotspot.lng, hotspot.radius);
        } else {
            coordinates = getRandomCoordsWithinBounds();
        }

        const feature = {
            type: "Feature",
            properties: {
                name: eventName,
                date: eventDate,
                highlighted,
                selected,
                id: i
            },
            geometry: {
                type: "Point",
                coordinates
            }
        };
        data.push(feature);
    }

    return data;
}


// Random number generator with seed
let currentSeed = 12345;  // Use your desired seed value
const rng = () => {
    const a = 1664525;
    const c = 1013904223;
    const m = 2 ** 32;
    currentSeed = (a * currentSeed + c) % m;
    return currentSeed / m;
};

// Helper function to generate random dates within the last 30 days using rng
// Ensure dates are at full hours (minute, second, and millisecond set to 0)
function generateRandomDates(count) {
    const currentDate = new Date();
    const last30DaysTimestamp = currentDate.getTime() - (30 * 24 * 60 * 60 * 1000);  // Timestamp for 30 days ago
    
    const randomDates = [];
    
    // Generate 'count' number of random dates
    for (let i = 0; i < count; i++) {
        const randomTime = last30DaysTimestamp + rng() * (currentDate.getTime() - last30DaysTimestamp);  // Random time within the last 30 days
        const randomDate = new Date(randomTime);
        
        // Adjust the date to the top of the hour (set minutes, seconds, and milliseconds to 0)
        randomDate.setMinutes(0);
        randomDate.setSeconds(0);
        randomDate.setMilliseconds(0);
        
        randomDates.push(randomDate.toISOString());  // Convert to ISO string format
    }
    
    return randomDates;
}

// Helper function to generate random weights using rng
function generateRandomWeights(count, min = 1, max = 5) {
    const weights = [];
    for (let i = 0; i < count; i++) {
        const randomWeight = Math.floor(rng() * (max - min + 1)) + min;
        weights.push(randomWeight);
    }
    return weights;
}

// Example usage
const generatedData = generateGeoJsonData({
    eventNames: ["Trash", "Wildlife", "Vandalism", "Weather", "Damage", "Other", "Dirt", "Fuel"],
    
    // Generate dates in the last 30 days using rng and ensure full hours
    eventDatesWithHours: generateRandomDates(50),

    allSelected: false,
    allHighlighted: false,
    
    proximityConfig: {
        hotspots: [
            { lat: 50.108958845453124, lng: 14.265167657637676, radius: 0.001, density: 15 },
            { lat: 50.1, lng: 14.26, radius: 0.001, density: 10 },
            { lat: 50.11, lng: 14.24, radius: 0.001, density: 10 }
        ]
    },
    
    eventOccurrenceConfig: {
        Trash: 0.5,
        Wildlife: 1,
        Vandalism: 1,
        Weather: 1,
        Damage: 1,
        Other: 0.5,
        Dirt: 1,
        Fuel: 1
    },
    
    hotspotEventWeights: {
        Trash: 0.5,
        Wildlife: 1,
        Vandalism: 50,
        Weather: 1,
        Damage: 1,
        Other: 0.5,
        Dirt: 1,
        Fuel: 1
    },
    
    // Generate random dates for hotspot time weights using rng (same as event dates)
    hotspotTimeWeights: generateRandomDates(3).reduce((acc, date, index) => {
        const weight = Math.floor(rng() * 5) + 1;
        acc[date] = weight;
        return acc;
    }, {}),
    
    // Generate random dates for normal time weights (same as hotspotTimeWeights logic)
    normalTimeWeights: generateRandomDates(10).reduce((acc, date, index) => {
        const weight = Math.floor(rng() * 2) + 1;
        acc[date] = weight;
        return acc;
    }, {}),
    
    totalPoints: 150,
    hotspotProbability: 0.25
});


}
